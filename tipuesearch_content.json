{"pages":[{"url":"http://localhost:8000/Linux文件读写机制及优化方式.html","text":"本文只讨论Linux下文件的读写机制，不涉及不同读取方式如read,fread,cin等的对比，这些读取方式本质上都是调用系统api read，只是做了不同封装。以下所有测试均使用open, read, write这一套系统api 缓存 缓存是用来减少高速设备访问低速设备所需平均时间的组件，文件读写涉及到计算机内存和磁盘，内存操作速度远远大于磁盘，如果每次调用read,write都去直接操作磁盘，一方面速度会被限制，一方面也会降低磁盘使用寿命，因此不管是对磁盘的读操作还是写操作，操作系统都会将数据缓存起来 Page Cache 页缓存（Page Cache）是位于内存和文件之间的缓冲区，它实际上也是一块内存区域，所有的文件IO（包括网络文件）都是直接和页缓存交互，操作系统通过一系列的数据结构，比如inode, address_space, struct page，实现将一个文件映射到页的级别，这些具体数据结构及之间的关系我们暂且不讨论，只需知道页缓存的存在以及它在文件IO中扮演着重要角色，很大一部分程度上，文件读写的优化就是对页缓存使用的优化 Dirty Page 页缓存对应文件中的一块区域，如果页缓存和对应的文件区域内容不一致，则该页缓存叫做脏页（Dirty Page）。对页缓存进行修改或者新建页缓存，只要没有刷磁盘，都会产生脏页 查看页缓存大小 linux上有两种方式查看页缓存大小，一种是free命令 $ free total used free shared buffers cached Mem: 20470840 1973416 18497424 164 270208 1202864 -/+ buffers/cache: 500344 19970496 Swap: 0 0 0 cached那一列就是页缓存大小，单位Byte 另一种是直接查看/proc/meminfo，这里我们只关注两个字段 Cached : 1202872 kB Dirty : 52 kB Cached是页缓存大小，Dirty是脏页大小 脏页回写参数 Linux有一些参数可以改变操作系统对脏页的回写行为 $ sysctl -a 2>/dev/null | grep dirty vm.dirty_background_ratio = 10 vm.dirty_background_bytes = 0 vm.dirty_ratio = 20 vm.dirty_bytes = 0 vm.dirty_writeback_centisecs = 500 vm.dirty_expire_centisecs = 3000 vm.dirty_background_ratio 是内存可以填充脏页的百分比，当脏页总大小达到这个比例后，系统后台进程就会开始将脏页刷磁盘（vm.dirty_background_bytes类似，只不过是通过字节数来设置） vm.dirty_ratio 是绝对的脏数据限制，内存里的脏数据百分比不能超过这个值。如果脏数据超过这个数量，新的IO请求将会被阻挡，直到脏数据被写进磁盘 vm.dirty_writeback_centisecs 指定多长时间做一次脏数据写回操作，单位为百分之一秒 vm.dirty_expire_centisecs 指定脏数据能存活的时间，单位为百分之一秒，比如这里设置为30秒，在操作系统进行写回操作时，如果脏数据在内存中超过30秒时，就会被写回磁盘 这些参数可以通过 sudo sysctl -w vm.dirty_background_ratio=5 这样的命令来修改，需要root权限，也可以在root用户下执行 echo 5 > /proc/sys/vm/dirty_background_ratio 来修改 文件读写流程 在有了页缓存和脏页的概念后，我们再来看文件的读写流程 读文件 用户发起read操作 操作系统查找页缓存 若未命中，则产生缺页异常，然后创建页缓存，并从磁盘读取相应页填充页缓存 若命中，则直接从页缓存返回要读取的内容 用户read调用完成 写文件 用户发起write操作 操作系统查找页缓存 若未命中，则产生缺页异常，然后创建页缓存，将用户传入的内容写入页缓存 若命中，则直接将用户传入的内容写入页缓存 用户write调用完成 页被修改后成为脏页，操作系统有两种机制将脏页写回磁盘 用户手动调用fsync() 由pdflush进程定时将脏页写回磁盘 页缓存和磁盘文件是有对应关系的，这种关系由操作系统维护，对页缓存的读写操作是在内核态完成，对用户来说是透明的 文件读写的优化思路 不同的优化方案适应于不同的使用场景，比如文件大小，读写频次等，这里我们不考虑修改系统参数的方案，修改系统参数总是有得有失，需要选择一个平衡点，这和业务相关度太高，比如是否要求数据的强一致性，是否容忍数据丢失等等。优化的思路有以下两个考虑点 最大化利用页缓存 减少系统api调用次数 第一点很容易理解，尽量让每次IO操作都命中页缓存，这比操作磁盘会快很多，第二点提到的系统api主要是read和write，由于系统调用会从用户态进入内核态，并且有些还伴随这内存数据的拷贝，因此在有些场景下减少系统调用也会提高性能 readahead readahead是一种非阻塞的系统调用，它会触发操作系统将文件内容预读到页缓存中，并且立马返回，函数原型如下 ssize_t readahead(int fd, off64_t offset, size_t count); 在通常情况下，调用readahead后立马调用read并不会提高读取速度，我们通常在批量读取或在读取之前一段时间调用readahead，假设如下场景，我们需要连续读取1000个1M的文件，有如下两个方案，伪代码如下 直接调用read函数 char* buf = (char*)malloc(10*1024*1024); for (int i = 0; i < 1000; ++i) { int fd = open_file(); int size = stat_file_size(); read(fd, buf, size); // do something with buf close(fd); } 先批量调用readahead再调用read int* fds = (int*)malloc(sizeof(int)*1000); int* fd_size = (int*)malloc(sizeof(int)*1000); for (int i = 0; i < 1000; ++i) { int fd = open_file(); int size = stat_file_size(); readahead(fd, 0, size); fds[i] = fd; fd_size[i] = size; } char* buf = (char*)malloc(10*1024*1024); for (int i = 0; i < 1000; ++i) { read(fds[i], buf, fd_size[i]); // do something with buf close(fds[i]); } 感兴趣的可以写代码实际测试一下，需要注意的是在测试前必须先回写脏页和清空页缓存，执行如下命令 sync && sudo sysctl -w vm.drop_caches=3 可通过查看/proc/meminfo中的Cached及Dirty项确认是否生效 通过测试发现，第二种方法比第一种读取速度大约提高10%-20%，这种场景下是批量执行readahead后立马执行read，优化空间有限，如果有一种场景可以在read之前一段时间调用readahead，那将大大提高read本身的读取速度 这种方案实际上是利用了操作系统的页缓存，即提前触发操作系统将文件读取到页缓存，并且操作系统对缺页处理、缓存命中、缓存淘汰都由一套完善的机制，虽然用户也可以针对自己的数据做缓存管理，但和直接使用页缓存比并没有多大差别，而且会增加维护代价 mmap mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系，函数原型如下 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。如下图所示 mmap除了可以减少read,write等系统调用以外，还可以减少内存的拷贝次数，比如在read调用时，一个完整的流程是操作系统读磁盘文件到页缓存，再从页缓存将数据拷贝到read传递的buffer里，而如果使用mmap之后，操作系统只需要将磁盘读到页缓存，然后用户就可以直接通过指针的方式操作mmap映射的内存，减少了从内核态到用户态的数据拷贝 mmap适合于对同一块区域频繁读写的情况，比如一个64M的文件存储了一些索引信息，我们需要频繁修改并持久化到磁盘，这样可以将文件通过mmap映射到用户虚拟内存，然后通过指针的方式修改内存区域，由操作系统自动将修改的部分刷回磁盘，也可以自己调用msync手动刷磁盘","tags":"Skill","title":"Linux文件读写机制及优化方式"},{"url":"http://localhost:8000/C++ & Python 多线程笔记.html","text":"C++ Posix多线程 #include <stdio.h> #include <stdlib.h> #include <pthread.h> #include <vector> using std :: vector ; void * Proc ( void * arg ) { pthread_t pthread = * ( pthread_t * ) arg ; printf ( \"this is thread %ld \\n \" , pthread ); } int main ( int argc , char ** argv ) { if ( argc != 2 ) { printf ( \"usage:%s thread_num\" , argv [ 0 ]); return 1 ; } int thread_num = atoi ( argv [ 1 ]); vector < pthread_t > threads ( thread_num ); for ( int i = 0 ; i < thread_num ; ++ i ) { pthread_t pthread ; pthread_create ( & pthread , NULL , & Proc , & threads [ i ]); threads [ i ] = pthread ; } for ( vector < pthread_t >:: iterator it = threads . begin (); it != threads . end (); ++ it ) { pthread_join ( * it , NULL ); } return 0 ; } boost多线程 全局函数作为线程函数 #include <stdio.h> #include <stdlib.h> #include <pthread.h> #include <vector> #include <string> #include <boost/thread.hpp> using std :: vector ; using std :: string ; void Proc ( int num , const string & str ) { printf ( \"this is thread %d, say %s \\n \" , num , str . c_str ()); } int main ( int argc , char ** argv ) { if ( argc != 2 ) { printf ( \"usage:%s thread_num\" , argv [ 0 ]); return 1 ; } int thread_num = atoi ( argv [ 1 ]); vector < boost :: thread *> threads ; for ( int i = 0 ; i < thread_num ; ++ i ) { boost :: thread * thread = new boost :: thread ( & Proc , i , \"Hello World!\" ); threads . push_back ( thread ); } for ( vector < boost :: thread *>:: iterator it = threads . begin (); it != threads . end (); ++ it ) { ( * it ) -> join (); } return 0 ; } 类成员函数作为线程函数 #include <stdio.h> #include <stdlib.h> #include <pthread.h> #include <vector> #include <string> #include <boost/thread.hpp> #include <boost/bind.hpp> using std :: vector ; using std :: string ; class Test { public : void Proc ( int num , const string & str ) { printf ( \"this is thread %d, say %s \\n \" , num , str . c_str ()); } }; int main ( int argc , char ** argv ) { if ( argc != 2 ) { printf ( \"usage:%s thread_num\" , argv [ 0 ]); return 1 ; } int thread_num = atoi ( argv [ 1 ]); vector < boost :: thread *> threads ; for ( int i = 0 ; i < thread_num ; ++ i ) { Test * test = new Test (); boost :: thread * thread = new boost :: thread ( boost :: bind ( & Test :: Proc , test , i , \"Hello World!\" )); threads . push_back ( thread ); } for ( vector < boost :: thread *>:: iterator it = threads . begin (); it != threads . end (); ++ it ) { ( * it ) -> join (); } return 0 ; } Python 使用threading模块 import sys import threading def proc ( num , str ): print 'this is thread %d , say %s ' % ( num , str ) def start_threads ( thread_num ): threads = [] for i in range ( thread_num ): thread = threading . Thread ( target = proc , args = ( i , \"Hello World!\" )) threads . append ( thread ) thread . start () for thread in threads : thread . join () if __name__ == '__main__' : if len ( sys . argv ) != 2 : print \"usage: %s thread_num\" % sys . argv [ 0 ] sys . exit ( 1 ) start_threads ( int ( sys . argv [ 1 ])) 使用multiprocessing模块 import sys from multiprocessing.dummy import Pool as ThreadPool def proc ( arg ): num , str = arg print 'this is thread %d , say %s ' % ( num , str ) def start_threads ( thread_num ): pool = ThreadPool ( thread_num ) args = [( i , \"Hello World!\" ) for i in range ( thread_num )] pool . map ( proc , args ) pool . close () pool . join () if __name__ == '__main__' : if len ( sys . argv ) != 2 : print \"usage: %s thread_num\" % sys . argv [ 0 ] sys . exit ( 1 ) start_threads ( int ( sys . argv [ 1 ]))","tags":"Language","title":"C++ & Python 多线程笔记"},{"url":"http://localhost:8000/C++ const知多少.html","text":"const修饰变量 关于const最常见的一个面试题是这样的：char *const和const char*有什么区别，大家都知道const修饰符代表的是常量，即const修饰的变量一旦被初始化是不能被更改的，这两个类型一个代表的是指针不可变，一个代表指针指向内容不可变，但具体哪个对应哪个，很多人一直搞不清楚。 有这样一个规律，const修饰的是它前面所有的数据类型，如果const在最前面，那么把它和它后面第一个数据类行交换.比如上面的const char*交换之后就是char const *，这样一来就很清楚了，char *const p中的const修饰的是char *（注意，我们这里把char和*都算作一种类型，这时候const修饰的是char和*的组合，也就是字符串指针），是一个指针类型，所以这时候指针p是不能变的，比如下面这段代码就会报错 char str1[]=\"str1\"; char str2[]=\"str2\"; char *const p = str1; p = str2; 这时候p是一个指针常量，它是不能指向别的地方的，但是它本身指向的内容是可以变的，比如下面的操作就是允许的 char str1[]=\"str1\"; char *const p = str1; p[0] = 'X'; printf(\"%s\", str1); 这时候str1的值就变成了\"Xtr1\" 我们再来看const char *p，根据前面提到的规律，将const和它后面一个类型交换变成char const *p（其实这种写法也是允许的，只是人们习惯将const写在最前面），这时候const修饰的是char，也就是说p指向的字符内容是不能变的。将上面两个例子的char *const p全部改成const char *p，则结果正好相反，第一个可以编译通过，第二个会报错。 其它时候就很好区分了，比如const int ，const string等等，总之，const修饰的是什么类型，这个类型的变量就不能被改变。 const修饰函数 先来看这样一个函数 const char * func(const char *str) const; 这样的函数比较夸张，有三个const，我们从左到右来一一说明： 1、第一个const修饰的是返回值，前面已经说过，这里的const修饰的是char，也就是说返回值的内容是不能被更改的 2、第二个const和第一个是一样的，这种用的比较多，它作为函数参数，表示的是这个参数在函数体内是不能被改动的（被传进来的实参并不要求是const类型），这样做是为了防止函数对实参做一些意外的操作，你试想下，当你调用一个函数时，你传进去一个变量是\"hello world!\"，调完函数之后变成了\"fuck the world!\"，这实在是不可忍的，所以我们在设计函数的时候，如果传进来的参数只作为读取使用，最好是将参数设成const类型。很多公司在面试让写代码的时候都会看中这个细节，你注意了这个细节不一定说明你牛逼，但你若没注意那肯定是会减分的。 3、再来说第三个const，按照我们最开始说的规律，const修饰的是它前面的所有数据类型，这里它前面的所有数据类型组合起来就是一个函数，这种类型一般出现在类成员函数里，当然，这里并不是说这个函数是不能变的，它代表的时这个函数不能改变类的成员变量，不管是public的还是private的 我们下面举例主要说明第三种情况，来看这样一个简单的程序 #include < stdio .h > class A { public : A () : x ( 0 ) , y ( 0 ) { } void func ( const int p ) { x = p ; y = p ; } int getY () { return y ; } int x ; private : int y ; } ; int main ( int argc , char * argv [] ) { A a ; printf ( \"x:%d y:%d\\n\" , a . x , a . getY ()); a . func ( 2 ); printf ( \"x:%d y:%d\\n\" , a . x , a . getY ()); return 0 ; } 这段代码是可以直接编译过的，运行结果是 x : 0 y : 0 x : 2 y : 2 我们稍作修改，将void func(const int p)改成void func(const int p) const再编译，就会直接报错，报错的两行代码是 x = p; y = p; 也就是说const类型的函数试图去修改类的成员变量是非法的，但是有一种情况例外，我们再在上面修改的基础上做一点修改，将int x改成mutable int x，将int y改成mutable int y，这时候程序又可以正常运行了，也就是说，如果成员变量是mutable类型的，它可以在任何场景下被修改。","tags":"Language","title":"C++ const知多少"},{"url":"http://localhost:8000/C++ extern用法详解.html","text":"昨天写完文章快零点，为了不浪费每天一次的群发资格，得赶在零点之前发送，刚给自己的个人微信号发了预览，Mac竟然死机了，看来一个月不关机还是会出点小问题。写的文章还没保存，这下只能是从手机复制粘贴发送到电脑上重新编辑了，于是狠了心按了强制关机。重新开机后发现，所有软件竟然全部恢复了死机前的状态，包括我那正在编辑还没保存的文稿，这里要为Mac系统点个赞！ 以上是题外话，今天的内容是编程相关的，非计算机专业的同学看到这里可以去干别的事了 extern声明变量无外乎如下两种： 1、声明全局变量 2、声明函数 今天我们只谈extern，什么const、static之类等等与之相关或不相关的一律忽略，下面就分别对以上两种情况一一讲解 声明和定义 既然提到extern声明变量，那我们就必须搞清楚声明和定义的区别。 这里我们将普通数据变量和函数统称变量。 从内存分配角度来说，声明和定义的区别在于声明一个变量不会分配内存，而定义一个变量会分配内存。 一个变量可以被声明多次，但是只能被定义一次。 基于以上前提，我们可以把声明和定义类比为指针和内存的关系。我们知道，指针其实就是指向内存的一个符号，变量的定义就好比一块内存区域，而声明就好比它的指针，可以有多个指针指向同一个内存区域，而一个指针只能指向一个内存区域，这样就很好理解为什么变量只能被定义一次，如果被定义多次，那就会分配多个内存，这样你通过变量的声明到底去找哪块内存区域呢，这会是个问题。 对于数据来说，声明和定义往往是同时存在的，比如下面的一行语句 int data; 这样既声明了 data 同时也定义了 data ，怎样做到只声明而不定义呢，用extern就可以了 extern int data； 对于函数来说，声明和定义就很容易区分了，一般我们会将声明放在头文件而将定义放在源文件里 void hello(); 这是一个函数的声明，而 void hello() { printf(\"hello world!\\n\"); } 这是一个函数的定义。当然，函数的声明和定义也可以同时发生，如果我们没有头文件而只有源文件，并且在源文件里并没有 void hello(); 这样的语句，那么这个函数的声明和定义就同时发生了，此时如果我们在原文件里想要调用函数 hello() ，你调用的代码必须在函数定义之后。 其实上面的要点只在于一句话： 使用变量之前必须声明，声明可以有多次，而定义只能有一次 。记住这句话，后面的就都很容易理解了。 extern声明全局变量 我们先来看如下例子，现有三个文件：test.h, test.cpp, main.cpp，其中main.cpp和test.cpp需要共享一个变量g_name，三个文件的内容如下 /* test.h */ #ifndef _TEST_H_ #define _TEST_H_ #include <string> std :: string g_name ; void hello (); #endif /* test.cpp */ #include <stdio.h> #include \"test.h\" void hello () { printf ( \"hello %s! \\n \" , g_name . c_str ()); } /* main.cpp */ #include \"test.h\" std :: string g_name ; int main () { g_name = \"Handy\" ; hello (); return 0 ; } 三者关系为，test.cpp包含了test.h，main.cpp也包含了test.h，这里的包含其实就是include。我们执行编译命令 g++ main.cpp test.cpp 编译报错 redefinition of 'g_name' ，说的是 g_name 被重定义了 我们看一下 g_name 出现的地方，一个是在test.h里，一个是在main.cpp里，两条语句都是 std::string g_name ，前面我们已经说过，这样的方式既声明也定义了变量，那g_name是如何被重定义的呢，首先我们需要理解include的含义，我们可以将include一个头文件理解为在该行展开头文件里的所有代码，由于main.cpp包含了test.h，我们在那一行将test.h的内容展开，就会发现main.cpp里有两句 std::string g_name; 所以在main.cpp里，g_name被定义了两次。 由于我们可以将include头文件理解为展开代码，所以编译的时候其实不需要指定头文件，只需要源文件就够了。需要注意的是，重定义并不是指在同一个原文件里定义多次，而是指在整个代码空间里，比如上面的例子是就是指在test.cpp和main.cpp里，其实上面的例子里g_name是被重定义了三次，其中test.cpp里一次，main.cpp里两次。 那上面重定义的问题怎么解决呢，很简答，将test.h里的 std::string g_name; 改为 extern std::string g_name; 就可以了，由于extern语句只声明变量而不定义变量，因此test.cpp和main.cpp展开头文件后，也只是将g_name声明了两次，而真正的定义还是在main.cpp里 extern声明函数 还是上面的例子，我们怎么在main.cpp里不包含头文件就可以调用hello函数呢，既然今天的主题是extern，不用提醒也知道，使用extern就可以了，代码如下 /* test.cpp */ #include <string> #include <stdio.h> // 声明g_name extern std :: string g_name ; // 声明和定义void hello() void hello () { printf ( \"hello %s! \\n \" , g_name . c_str ()); } /* main.cpp */ #include <string> // 声明和定义g_name std :: string g_name ; // 声明void hello() extern void hello (); int main () { g_name = \"Handy\" ; hello (); return 0 ; } 注意这里用到extern声明变量和函数两种场景，我分别在语句后面做了注释。编译命令如下 g++ main.cpp test.cpp 这里我们并没有用到头文件，但是依然可以在不同文件间共享变量和函数，这一切都是extern的功劳！ 总结 要了解extern主要搞清以下几个概念： 1、声明和定义的区别。全局代码空间里，变量可以有多个声明，但只能有一个定义 2、include头文件等同于展开头文件里的代码 了解了以上两点，再来分析extern的用法，是不是就会清晰很多了 点击阅读原文查看我的博客，如果觉得这篇文章有价值，请点个赞，也希望能为我增加一个读者","tags":"Language","title":"C++ extern用法详解"},{"url":"http://localhost:8000/C++管理读写锁的一种实现方法.html","text":"读写锁是一种常用的线程同步机制，在多线程环境下访问同一内存区域时往往会用到，本篇不是介绍读写锁的原理，而是在假设读者都知道读写锁的基本使用方式的前提下，介绍一种管理读写锁的方法 读写锁的基本使用 === 为了读起来好理解，还是先介绍一下基本概念和使用 基本概念 读写锁有三种状态：读模式加锁，写模式加锁，不加锁 读写锁的使用规则 在当前没有写锁的情况下，读者可以立马获取读锁 在当前没有读锁和写锁的情况下，写者可以立马获取写锁 也就是说，可以多个读者同时获取读锁，而写者只能有一个，且在写的时候不能读 基本使用 初始化和销毁 int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); 读和写 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); 另外还有非阻塞模式的读写 int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); 解锁 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 示例 test.cpp #include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <pthread.h> #define ARRAY_SIZE 10 int g_array [ ARRAY_SIZE ]; pthread_rwlock_t g_mutex ; void * thread_func ( void * arg ) { while ( true ) { int index = random () % ARRAY_SIZE ; if ( 0 == random () % 2 ) { // read pthread_rwlock_rdlock ( & g_mutex ); printf ( \"read array[%d]:%d \\n \" , index , g_array [ index ]); } else { // write pthread_rwlock_wrlock ( & g_mutex ); int value = random () % 100 ; g_array [ index ] = value ; printf ( \"write array[%d]:%d \\n \" , index , value ); } pthread_rwlock_unlock ( & g_mutex ); sleep ( 2 ); } } int main ( int argc , char * argv []) { pthread_rwlock_init ( & g_mutex , NULL ); srand (( unsigned ) time ( NULL )); int pthread_num = 10 ; pthread_t threads [ pthread_num ]; for ( int i = 0 ; i < pthread_num ; ++ i ) { pthread_create ( & threads [ i ], NULL , thread_func , NULL ); } for ( int i = 0 ; i < pthread_num ; ++ i ) { pthread_join ( threads [ i ], NULL ); } pthread_rwlock_destroy ( & g_mutex ); return 0 ; } 这段代码可以直接编译运行 g++ test.cpp -o test ./test 读写锁的管理 === 通过上面的代码我们可以了解读写锁的基本使用方法，在需要读的时候调用读锁命令，需要写的时候调用写锁命令，读写完后调用解锁命令，这样使用虽然简单易懂，但是有时候会让代码很繁琐，比如当你调用了读锁命令后，程序可能会有多个出口，如果不使用goto语句的话（goto语句在某些编程规范里是明令禁止的，苹果曾经因为goto语句导致SSL连接验证的bug，有一篇文章分析得很好，可以参考一下 由苹果的低级Bug想到的编程思考 ），那你需要在每个出口都调用一次解锁操作，这样就失去了程序的优雅性，我们用下面的伪代码片段来描述这种情况 int func() { pthread_rwlock_rdlock(&g_mutex); if (condition1) { // do something pthread_rwlock_unlock(&g_mutex); return -1 } else if(condition2) { // do something pthread_rwlock_unlock(&g_mutex); return -2; } else { // do something } pthread_rwlock_unlock(&g_mutex); return 0; } 这个程序有多个出口，在每个出口我们都要手动调用一次解锁，很显然这不是我们期望的样子，那理想的情况应该是怎样的呢，它应该是只需显式的调用一次加锁操作，在每个出口会自动调用解锁，于是我们很容易想到用类来管理，在程序入口定义一个类对象，在构造函数里调用加锁操作，当程序return后，类对象会自动析构，我们在析构函数里实现解锁，这样就不用每次手动去调用解锁操作了。管理读写锁的类的实现如下，我们把代码放在头文件rwlock.h下 #ifndef _RWLOCK_H_ #define _RWLOCK_H_ #include <iostream> #include <pthread.h> enum ELockType { READ_LOCKER , WRITE_LOCKER , }; class RWLockManager ; class RWLock { public : typedef RWLockManager Lock ; RWLock () { pthread_rwlockattr_t attr ; pthread_rwlockattr_init ( & attr ); pthread_rwlock_init ( & m_rwlock , & attr ); } virtual ~ RWLock () { pthread_rwlock_destroy ( & m_rwlock ); } int rdlock () { return pthread_rwlock_rdlock ( & m_rwlock ); } int wrlock () { return pthread_rwlock_wrlock ( & m_rwlock ); } int unlock () { return pthread_rwlock_unlock ( & m_rwlock ); } private : pthread_rwlock_t m_rwlock ; }; class RWLockManager { public : RWLockManager ( RWLock & locker , const ELockType lock_type ) : m_locker ( locker ) { if ( lock_type == READ_LOCKER ) { int ret = m_locker . rdlock (); if ( ret != 0 ) { std :: cout << \"lock failed, ret: \" << ret ; } } else { int ret = m_locker . wrlock (); if ( ret != 0 ) { std :: cout << \"lock failed, ret: \" << ret ; } } } ~ RWLockManager () { int ret = m_locker . unlock (); if ( ret != 0 ) { std :: cout << \"unlock failed, ret: \" << ret ; } } private : RWLock & m_locker ; }; #endif 注意类RWLockManager的成员变量m_lock必须是一个RWLock类型的引用 这样在使用起来的时候就很简单明了，还是上面那份伪代码，使用读写锁管理类之后如下 int func () { RWLock :: Lock lock ( g_mutex , READ_LOCKER ); if ( condition1 ) { // do something return -1 } else if ( condition2 ) { // do something return -2 ; } else { // do something } return 0 ; } 总结 === 以上就是管理读写锁的一种方式，只要稍微花点心思就可以让代码变得简洁清晰，程序的根本目的是消除重复劳动，如果我们在写代码的时候要重复写了很多遍某些语句，那么我们就应该考虑是不是设计一个方法消除这种重复。","tags":"Language","title":"C++管理读写锁的一种实现方法"},{"url":"http://localhost:8000/Mac OS X重装操作系统.html","text":"一个月关一次机，两年都不重装系统，这在Mac上是很正常的事情。但是这只适合于普通的用户，对于爱折腾的人来说，不重装几次系统就好像自己对它爱得不够深一样。我这次也是为了尝鲜，从10.9升级到10.10的测试版，可能是测试版不够稳定，或者因为我是air低配版的原因，系统运行起来比较卡顿，而且借鉴IOS7扁平化的设计图标在电脑上看来实在是太刺眼，10.10的新特性也主要体现在和IOS系统的协同工作上，对于没有IOS设备的我来说，10.10实在是不如稳定的10.9让人舒服，因此我又将系统回滚到了10.9，这次我主要说说系统回滚和重装的问题。 这里的重装我们指重新安装同一版本的系统，回滚指从高版本退回到低版本的系统。为什么不说升级？因为升级很简单，直接去App Store下载最新的系统就行。 不管是哪种安装方式，主要有三个途径 通过Time Machine恢复 在线重装 自制U盘安装。 通过Time Machine恢复 这种方式是Mac的特色。Time Machine是Mac用来备份系统和文件的工具，当然，你需要有一个足够大的硬盘，在你第一次通过Time Machine备份系统时，它会将整个系统全部备份到指定硬盘上，第一次会比较耗时，比如我第一次备份总量是80G，花了一晚上还没备份好，最后甚至将移动硬盘分区表写坏了。所以建议刚买电脑的时候就备份一次，后续都可以增量备份，我重装之后备份50G只花了两个小时左右。Time Machine翻译过来叫时间机器，既然如此称呼，当然不只是有备份系统这样简单的功能，由于它是增量备份，每次备份时它都可以根据增量的内容建立快照，在你恢复系统时可以选择任意一个备份时间点，就好比乘坐时间机器可以回到过去任何时刻 通过Time Machine恢复系统的方式很简单，开机时按住CMD+R键不放，进入系统安装界面，里面有\"通过Time Machine恢复系统\"选项，直接选择就行。 这种方式既可以重装又可以回滚，取决于你Time Machine备份的系统版本，如果你用Time Machine备份的是低版本的系统，那么就会回滚到系版本 在线安装 这也是Mac有别于windows的地方，由于10.9是免费系统，因此苹果提供了在线安装的功能，如果你不小心将系统弄坏了，而且也没有用Time Machine备份，制作U盘启动盘安装又太麻烦，那么你可以选择这种方式。 同样是开机时按住CMD+R键不放，直到进入系统安装界面，有一个选项是通过网络安装系统，这时你需要先连接WiFi，根据我的经历，貌似此时是无法连接以太网的，也就是说插网线不能联网，所以最好是用WiFi，连上WiFi之后根据提示安装即可。 这种安装方式是不能回滚到，比如我是10.10系统，通过这种方式安装的还是10.10系统，这样安装之后只会替换系统文件，用户文件还会是原来的样子。 自制U盘安装 和windows一样，Mac也可以通过自制U盘启动盘来安装系统，这种安装方式是最复杂的，不过也是最随心所欲的，你可以升级、回滚、重装，都可以，在通过这种方式安装时，请严格安装下面的步骤 制作U盘启动 首先你需要一个至少8G的U盘，不过最好是用移动硬盘，可以给移动硬盘分一个10G左右的分区，将其制作成启动盘，一般来说移动硬盘的速度是快于U盘的。打开磁盘工具（Mac自带的），选中你要制作的分区（如果是U盘，只有一个分区，如果是移动硬盘可以自己先进行分区），点击\"抹点\"标签，格式选择\"Mac OS扩展\"，名称填Mavericks（这个名字后面会用到）点击抹掉，此时分区被格式化为指定格式，这种格式只有Mac能识别，windows是不识别的。 下载系统安装包，对于不同版本的制作方式也不同，由于我制作的是10.9的系统，这里也以此为例，下载地址为 http://pan.baidu.com/s/1hqDrQSG ，如果直接下载貌似速度比较慢，通过百度云管家下载会快一些，但是百度云管家只有windows版本的，所以身旁如果有windows电脑可以先用windows电脑下载好再拷贝到Mac上 同时选中两个文件，双击解压，得到一个dmg后缀的文件，双击dmg文件，此时文件被挂载到了Mac上，通过Finder左侧的设备可以看到。怎么查看挂载的目录呢，打开终端软件，输入df -h，可以查看系统所有挂载的设备，最后一列是设备挂载的路径，相信聪明的你一定可以判断哪个路径对应哪个设备（一般通过名字和Size、Used等特征判断），此时确保U盘和系统安装包都被挂载了 打开终端软件，输入如下命令，其中有几个地方是需要替换成你自己的路径的 sudo /Volumes/Install\\ OS\\ X\\ Mavericks.app/Contents/Resources/createinstallmedia --volume /Volumes/Mavericks --applicationpath /Volumes/Install\\ OS\\ X\\ Mavericks.app --nointeraction 这条命令的意思是，通过路径为/Volumes/Install\\ OS\\ X\\ Mavericks.app/Contents/Resources/createinstallmedia的程序，将文件/Volumes/Install\\ OS\\ X\\ Mavericks.app安装到设备/Volumes/Mavericks中，其中/Volumes/Install\\ OS\\ X\\ Mavericks.app是挂载的系统安装包，/Volumes/Mavericks是挂载的U盘（前面提到过，在抹掉时命名为Mavericks），将这几个替换成自己对应的路径就可以，注意，如果文件名里有空格，前面是要加反斜杠\"\\\"的 回车之后等待一会儿，U盘启动器就安装成功了 从U盘启动系统 重启电脑，开机时按住option键不放，直到进入磁盘选择界面，选择你自己的磁盘 之后会进入一个界面，有\"通过Time Machine恢复\"，\"安装OS X\"等选项，此时你有两个选择 1、通过菜单栏的磁盘工具抹掉系统硬盘，磁盘工具的使用和制作U盘启动时一样，将系统盘抹掉，格式化为Mac OS扩展格式。然后选择\"安装OS X\"，将系统安装到抹掉的硬盘里。此种方式会删除所有数据 2、直接点击\"安装Os X\"，将U盘里的系统安装到系统盘上，这种方式是覆盖安装，只会替换系统文件，用户文件还在 以上三种方式分别对应不同的场景需求，最简单也最保险的当然是通过Time Machine备份系统，所以在此也提醒各位在升级系统前一定要备份，否则你将尝到无尽折腾的味道。另外，由于Time Machine无法选择部分文件备份，觉得备份太慢且只想备份部分文件或软件时，可以自己用移动硬盘拷贝，由于Mac下的软件都类似于Windows下的绿色软件，也就是说你将/Applications目录下的软件考走，放到另一台Mac的/Applications目录下，一样是可以运行的，所以你可以像拷贝文件一样将软件拷贝的移动硬盘，重装系统后再将软件拷贝到/Applications下即可，这种方式经本人试验大部分软件都可用。 最后为这几天的折腾总结一下： 没事别折腾系统 就算要折腾系统，也一定要用Time Machine先备份 如果没有备份，且将系统折腾死了，那你就只能看这篇文章了 The end...","tags":"Skill","title":"Mac OS X重装操作系统"},{"url":"http://localhost:8000/Mac必备软件推荐.html","text":"随着IOS的流行，Mac电脑也越来越多的进入人们的视野，和iPhone系列一样，苹果的Mac产品线也是软硬件完美结合，有着非同凡响的使用体验，而这主要的功劳，当属其操作系统Mac OS X，今天就来推荐一些Mac必备软件 首先要声明一点，OS X系统的很多软件和IOS一样，都是收费的，国人惯用了微软的盗版系统和大量windows盗版软件，转到Mac平台会有少许不适，当然Mac平台也有破解版软件，但本着程序员的良心，本文不会贴出破解软件的下载链接，对于收费软件也会专门指出，经济条件允许的同学，希望能多多支持正版。我主要是站在程序员的角度推荐软件，所以像QQ、搜狗输入法之类的日常软件不在推荐之列，当然，有些软件也适合普通用户，而且是强烈推荐，希望读者能各取所需 必备 Alfred 用神器来形容这款软件一点都不为过，至少我在windows平台还没用过让我这么舒适的软件 功能介绍 初级功能：搜索并打开软件与文件 高级功能：自定义搜索、通过插件实现特殊功能 Alfred的唤出方式为option+空格，下面的所有操作都是先按option+空格再输入的。Alfred的设计理念是将所有操作都集中到一个入口，这个很类似Linux的shell命令，不管你在任何目录下，所有系统命令都可以通过命令行输入使用，这可以省去你大量的查找和定位时间 搜索软件 有了Alfred，你不用去整理安装过的软件，只要你记得它的名字，或者哪怕是一个字母，都可以快速定位并打开软件，比如我要打开QQ，输入qq，它就会给我这样的选项 通过方向键选择软件，回车可以打开选中的软件，或者通过 cmd+数字 打开对应的软件，它会根据你每次的选择来自动对结果进行排序，因为我经常通过这种方式打开企业QQ，而我的QQ是直接在dock栏打开，所以企业QQ会排在QQ的前面，另外，它搜索软件时会通过两种方式进行匹配，一种是软件名，一种是软件对应的文件名，比如企业QQ的软件名是\"企业QQ\"，而它的文件名是\"EIM.app\"，这两种方式都可以用来定位并且对中文支持良好 搜索文件 搜索文件的方式大同小异，先输入空格，默认就会搜索文件，比如我输入 空格+python 就会有如下的搜索结果，回车打开文件，cmd+回车打开Finder进入文件所在目录 自定义网页搜索 接下来我要推荐它的自定义搜索功能，先看图 这里我输入 jd iphone ，回车之后就会跳转到京东的iphone搜索页面，也就是这个链接 http://search.jd.com/Search?keyword=iphone&enc=utf-8 ，这里用到了Alfred的web search功能，这需要自己进行配置，配置方式也很简单，打开Alfred的配置界面（ option+空格 打开Alfred， cmd+, 打开配置项），在feature菜单中选择web search一项，点击右下角的Add Custom Search，按下图配置 最重要的是Search URL一栏，前面已经说过，京东搜索关键词iphone的链接是 http://search.jd.com/Search?keyword=iphone&enc=utf-8 ，这里我们只需要将链接中的iphone替换成{query}即可，这个链接是怎么发现的呢，很简单，你打开京东，随便输入一个关键词进行搜索（最好是搜英文，中文在URL中会被转码），看一下你输入的词在URL中的哪个地方，替换成{query}就可以了，下图是我自定义的一些搜索以及对应的链接 京东 ：http://search.jd.com/Search?keyword={query}&enc=utf-8 百度 ：http://www.baidu.com/s?wd={query} bt天堂 ：http://www.bttiantang.com/s.php?q={query} 豆瓣电影：http://movie.douban.com/subject_search?search_text={query} 淘宝 ：http://s.taobao.com/search?q={query} 有了这个，你就可以在任何界面下快速进行搜索，比如你在看一个PDF文档发现一个专有名词想用百度搜索，这时你无须打开浏览器进入百度再输入关键词，而是 option+空格 打开Alfred，输入 bd 你想要的balabala 就可以快速搜索 以上功能都是免费的！应付日常使用完全够了，如果想用高级功能，比如通过编写插件完成更复杂的动作，就需要升级到专业版，个人觉得免费版就已经够用了，除非你想深入研究这个东东的使用 效率 BetterTouchTool 这是一款免费软件，可以自定义触摸板和鼠标操作，添加操作的步骤如下 1. 选择操作的对象，可以对Magic Mouse，触摸板等进行操作 2. 选择动作执行的对象，可以是全局动作，也可以是针对某个应用的动作 3. 添加手势 4. 选择手势 5. 选择映射的快捷键或操作，二选一 这个软件全是英文说明，需要一点耐心来看，不过都是一些简单句子，相信英语过了四级的理解起来完全无压力。通过上图可以看到，我在全局范围添加了两个手势，分别轻按触摸板顶部中间位置和底部中间位置可以滚动到页面顶部或底部，滚动到页面顶部或底部是我在windows浏览器上最常用的鼠标手势，Mac下虽然没有那些浏览器插件和鼠标可用，但是通过这种方式我们可以实现同样的功能，甚至更加强大，这个动作是对所有软件都有效的！ 同理，我们也可以对MagicMouse进行设置，注意必须是苹果的MagicMouse，普通鼠标是不支持的。MagicMouse的动作和触摸板会有所不同，细节就不说了，总之你可以将常用的操作全部集成到鼠标上，那时你就会明白为什么MagicMouse叫做MagicMouse。不了解MagicMouse的人会吐槽它很难用，了解的人只会暗自偷笑 另外，在Basic Settings标签下，建议将左下角的Enable Windows Snapping勾选上，这样可以实现和win7类似的将软件窗口拖到屏幕顶端实现放大的功能，除此之外，你还可以试试将软件窗口拖到屏幕左边、右边以及四个角落，看看是什么效果 AppClean 轻量级的卸载软件的工具，在windows下如果要卸载软件该如何操作？通过控制面板？那个太高端，很多普通用户都不会使用。通过360安全卫士？拜托，那简直就是一个杂货店，我只想要一瓶啤酒，它非得送我一包卫生纸。Mac下完全不需要像360安全卫士这样臃肿的软件，Unix软件设计的宗旨是只干一件事并做到极致，实现软件卸载，只需要AppClean就可以了 通过Alfred启动软件（现学现用嘛，option+空格唤出Alfred，输入cleaner，回车打开软件），如下图 它的搜索功能颜色比较淡，我好长时间才发现，通过搜索找到你要卸载的软件，或者直接在列表里找到，勾选之后点击右下角的Search按键，它会搜索出软件相关的目录，点击delete，搞定！ 是不是觉得简单的不可思议，印象中windows下卸载一个软件得花老半天，其实卸载软件无非就是删除文件，在Mac下，软件包含的文件被有规律的组织在一起，这使得安装和卸载都变得异常简单 最后需要注意一点，AppCleaner的搜索功能只能对软件的文件名进行搜索，对于有些软件名和文件名不一致的，输入软件名是搜不到的，比如企业QQ的文件名是EIM.app，只能通过搜索EIM找到软件，或者浏览软件列表选中，至于怎么通过软件名得到文件名，试试Alfred：） PhoneClean 如果想深度清理系统垃圾，就需要用到这个软件，收费软件，这里不做过多介绍，使用起来非常容易 AndroidFileTransfer 浏览安装设备文件，无须多言 Windows Phone 同步WP设备文件，无须多言 开发 前面推荐的软件是适用于所有用户的，所以讲的比较详细，有些还贴出了使用步骤截图，下面介绍专门针对程序员的软件，由于程序员都有极强的动手能力和好奇心，所以下面的软件介绍都一笔带过，只做推荐，不做详解 Xcode IOS开发必备，即便不做IOS开发，也建议安装，它就像windows下的VS，可能其它软件使用时会依赖它，所以强烈建议安装，AppStore可免费下载 iTerm 终端模拟程序，虽然Mac自带Terminal程序，但这个更带感配置也更丰富，光看这个透明背景就让人醉了，更重要的是它是免费的！ MacVim vim的GUI版，Mac专有，完美兼容vim所有插件以及语法，vim遇到Mac，是我用过的最好的编辑器！ 想要最大发挥它的威力，前提是你必须是一个Vimer，建议先熟练使用vim后再转到MacVim Homebrew 二进制包管理工具，类似Ubuntu的apt-get和CentOS的yum。可以通过它安装很多Mac没提供或提供了但不好使的UNIX软件，比如ctags，wget，git等 官网可下载 http://brew.sh 安装brew $ ruby -e \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install ) \" 通过brew安装软件 $ brew install wget brew -h 查看详细使用说明 DiffMerge 文件/目录比较工具。虽然vim很强大，也可提供文件比较功能，但这种场景下图形界面会更直观 Mou 最后登场的是Mou，免费软件，基于Markdown语法的编辑器，我觉得我有必要专门花一篇文章来讲它，原因只有一个，我的所有博客都是用它来写的！但，今天就到这里了 EOF","tags":"Skill","title":"Mac必备软件推荐"},{"url":"http://localhost:8000/Python import机制备忘笔记.html","text":"python的模块有两种组织方式，一种是单纯的python文件，文件名就是模块名，一种是包，包是一个包含了若干python文件的目录，目录下必须有一个文件 __init__.py ，这样目录名字就是模块名，包里的python文件也可以通过 包名.文件名 的方式import import语法 import语法有两种 直接import模块 import Module import Module as xx 从模块import对象（下级模块，类，函数，变量等） from Module import Name from Module immport Name as yy as语法是用来设置对象（这里用对象泛指模块，类，函数等等）别名，import将对象名字引入了当前文件的名字空间 假设有如下目录结构 ├── A.py └── pkg ├── B.py └── __init__.py 在当前目录下，以下语句都是有效的 import A import pkg import pkg.B from pkg import B 为了简化讨论，下面将不会对as语法进行举例 import步骤 python所有加载的模块信息都存放在sys.modules结构中，当import一个模块时，会按如下步骤来进行 如果是 import A ，检查sys.modules中是否已经有A，如果有则不加载，如果没有则为A创建module对象，并加载A 如果是 from A import B ，先为A创建module对象，再解析A，从中寻找B并填充到A的 __dict__ 中 嵌套import 在import模块时我们可能会担心一个模块会不会被import多次，假设有A，B，C三个模块，A需要import B和C，B又要import C，这样A会执行到两次import C，一次是自己本身import，一次是在import B时执行的import，但根据上面讲到的import步骤，在第二次import时发现模块已经被加载，所以不会重复import 但如下情况却会报错 #filename: A.py from B import BB class AA : pass #filename: B.py from A import AA class BB : pass 这时不管是执行A.py还是B.py都会抛出ImportError的异常，假设我们执行的是A.py，究其原因如下 文件A.py执行 from B import BB ，会先扫描B.py，同时在A的名字空间中为B创建module对象，试图从B中查找BB 扫描B.py第一行执行 from A import AA ，此时又会去扫描A.py 扫描A.py第一行执行 from B import BB ，由于步骤1已经为B创建module对象，所以会直接从B的module对象的 __dict__ 中获取BB，此时显然BB是获取不到的，于是抛出异常 解决这种情况有两种办法， 将 from B import BB 改为 import B ，或将 from A import AA 改为 import A 将A.py或B.py中的两行代码交换位置 总之，import需要注意的是，尽量在需要用到时再import 包的import 当一个目录下有 __init__.py 文件时，该目录就是一个python的包 import包和import单个文件是一样的，我们可以这样类比： import单个文件时，文件里的类，函数，变量都可以作为import的对象 import包时，包里的子包，文件，以及__init__.py里的类，函数，变量都可以作为import的对象 假设有如下目录结构 pkg ├── __init__.py └── file.py 其中 __init__.py 内容如下 argument = 0 class A:pass 在和pkg同级目录下执行如下语句都是OK的 >>> import pkg >>> import pkg.file >>> from pkg import file >>> from pkg import A >>> from pkg import argument 但如下语句是错误的 >>> import pkg.A >>> import pkg.argument 报错 ImportError: No module named xxx ，因为当我们执行 import A.B ，A和B都必须是模块（文件或包） 相对导入和绝对导入 绝对导入的格式为 import A.B 或 from A import B ，相对导入格式为 from . import B 或 from ..A import B ， . 代表当前模块， .. 代表上层模块， ... 代表上上层模块，依次类推。当我们有多个包时，就可能有需求从一个包import另一个包的内容，这就会产生绝对导入，而这也往往是最容易发生错误的时候，还是以具体例子来说明 目录结构如下 app ├── __inti__.py ├── mod1 │ ├── file1.py │ └── __init__.py ├── mod2 │ ├── file2.py │ └── __init__.py └── start.py 其中app/start.py内容为 import mod1.file1 app/mod1/file1.py内容为 from ..mod2 import file2 为了便于分析，我们在所有py文件（包括 __init__.py ）第一行加入 print __file__, __name__ 现在app/mod1/file1.py里用到了相对导入，我们在app/mod1下执行 python file1.py 或者在app下执行 python mod1/file1.py 都会报错 ValueError: Attempted relative import in non-package 在app下执行 python -m mod1.file1 或 python start.py 都会报错 ValueError: Attempted relative import beyond toplevel package 具体原因后面再说，我们先来看一下导入模块时的一些规则 在没有明确指定包结构的情况下，python是根据 __name__ 来决定一个模块在包中的结构的，如果是 __main__ 则它本身是顶层模块，没有包结构，如果是 A.B.C 结构，那么顶层模块是A。基本上遵循这样的原则 如果是绝对导入， 一个模块只能导入自身的子模块或和它的顶层模块同级别的模块及其子模块 如果是相对导入， 一个模块必须有包结构且只能导入它的顶层模块内部的模块 有目录结构如下 A ├── B1 │ ├── C1 │ │ └── file.py │ └── C2 └── B2 其中A，B1，B2，C1，C2都为包，这里为了展示简单没有列出 __init__.py 文件，当file.py的包结构为 A.B1.C1.file （注意，是根据 __name__ 来的，而不是磁盘的目录结构，在不同目录下执行file.py时对应的包目录结构都是不一样的）时，在file.py中可采用如下的绝对的导入 import A.B1.C2 import A.B2 和如下的相对导入 from .. import C2 from ... import B2 什么情况下会让file.py的包结构为 A.B1.C1.file 呢，有如下两种 在A的上层目录执行 python -m A.B1.C1.file ， 此时明确指定了包结构 在A的上层目录建立文件start.py，在start.py里有 import A.B1.C1.file ，然后执行 python start.py ，此时包结构是根据file.py的 __name__ 变量来的 再看前面出错的两种情况，第一种执行 python file1.py 和 python mod1/file1.py ，此时file.py的 __name__ 为 __main__ ，也就是说它本身就是顶层模块，并没有包结构，所以会报错 第二种情况，在执行 python -m mod1.file1 和 python start.py 时，前者明确告诉解释器mod1是顶层模块，后者需要导入file1，而file1.py的 __name__ 为mod1.file1，顶层模块为也mod1，所以在file1.py中执行 from ..mod2 import file2 时会报错 ，因为mod2并不在顶层模块mod1内部。通过错误堆栈可以看出，并不是在start.py中绝对导入时报错，而是在file1.py中相对导入报的错 那么如何才能偶正确执行呢，有两种方法，一种是在app上层目录执行python -m app.mod1.file1，另一种是改变目录结构，将所有包放在一个大包中，如下 app ├── pkg │ ├── __init__.py │ ├── mod1 │ │ ├── __init__.py │ │ └── file1.py │ └── mod2 │ ├── __init__.py │ └── file2.py └── start.py start.py内容改成 import pkg.mod1.file1 ，然后在app下执行 python start.py","tags":"Language","title":"Python import机制备忘笔记"},{"url":"http://localhost:8000/Vim c++开发环境插件安装详解.html","text":"C/C++是使用比例最高的程序语言，而vim是专为程序员开发的编辑器，当这两者结合起来，会给我们带来怎样的效果呢。 对于windows上做C++开发的用户来说，vs为他们做了大量的工作，语法高亮、自动缩进、智能提示等等，当你happy的使用vs时，请记住一点，这是一个收费软件，虽然在我大中华普遍都在使用微软的盗版软件，但作为程序员我们心里应该知道这是不对的行为，然后再去——等等，我们今天讨论的不是这个话题，我们要说的是Linux下的免费软件vim！ vim插件安装的教程在互联网上已经数不胜数，但是质量也参差不齐，很多都是在其它地方转载copy，而且没有注明使用环境，很多人安装时发现无法work，最后搞得一团糟，今天这篇文章的宗旨只有两个：1、使得安装简单；2、保证可以用。 阅读这篇文章的前提是你至少使用过vim，知道基本的操作。下面就开始进入主题。 安装环境 CentOS release 6.3 (Final) VIM 7.2 本文的插件安装均在以上环境中进行，顺带也会提一下其它平台的安装方式。 准备工作 由于大多数vim插件都可以在github上找到，而且通过git安装、删除、升级插件都异常简单，因此我们需要首先安装git工具，如果不知道git和github，可以先自行Google centos安装 sudo yum install git ubuntu安装 sudo apt-get install git Mac安装 由于Mac没有像yum和apt-get一样的包管理工具，需要先安装一个类似的包管理工具，这对于安装一些Linux命令是非常有帮助的 安装包管理工具 homebrew ruby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)\" 通过brew安装git brew install git 我将本文需要安装的插件和配置文件都放在了github上，如果你不想大费周折的了解每个插件的安装方式，可以直接下载所有插件即可使用，项目地址 https://github.com/handy1989/vim ，可以按照如下命令备份并一次安装所有插件（注意，从git上下载的vim目录下都是隐藏文件， ls -a 可以查看） mv ~/.vimrc ~/.vimrcbak mv ~/.vim ~/.vimbak git clone https://github.com/handy1989/vim.git mv vim/.vimrc ~/.vim ~/ 第一个插件 为了不让插件安装后目录显得凌乱，我们很有必要安装一个管理插件的插件，这样功能的插件有好几个，这里只推荐一个 pathogen 项目地址 https://github.com/tpope/vim-pathogen 安装 可以通过git安装，也可以直接下载插件文件，由于这个插件只有一个文件，我们选择后者，而该插件的说明文档上也是用的这种方法。 mkdir -p ~/.vim/autoload ~/.vim/bundle && curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 然后，就没有然后，这个插件就安装完了。是不是觉得so easy! 不过先别急，我们还要对插件进行一些配置，用vim打开~/.vimrc，输入如下三行类容 execute pathogen#infect() syntax on filetype plugin indent on 保存退出，这个插件的安装配置就完成了，怎么验证插件有没有生效呢，别急，后面有的是机会验证。我们先来讲讲vim插件是个什么东西。 此时你的~/.vim目录结构应该是这样的 ├── autoload │ └── pathogen.vim └── bundle 可见~/.vim目录下是有两个目录，其中autoload放的是pathogen插件，所谓的插件其实就是一个脚本，当vim启动时，它会自动加载~/.vim/autoload目录下的脚本，由于你~/.vimrc里配置了 execute pathogen#infect() ，所以它会去自动的执行脚本里这个函数，至于这个函数是怎么实现的，我们不用管它，总之这个函数的功能就是去加载~/.vim/bundle目录下你安装的所有插件，pathogen的管理方法大致就是这样，而我们也看到，vim的插件其实就是一个脚本文件，丰富一点的还会带有说明文档等其它内容，后面我们碰到了再讲解。 auto-pairs 项目地址 https://github.com/jiangmiao/auto-pairs （感兴趣的可以看） 功能 自动匹配括号、引号等 安装 git clone git://github.com/jiangmiao/auto-pairs.git ~/.vim/bundle/auto-pairs 这样就将auto-pairs在github上的项目文件下载到了~/.vim/bundle/auto-pairs目录下 测试 随便打开一个文件，输入左括号'('，看右括号是不是自动出现了，然后删除左括号，看右括号是不是也被删除了。当然功能远不止这些，但常用的就这几点。 NERDTree 项目地址 https://github.com/scrooloose/nerdtree 功能 显示目录树 安装 git clone https://github.com/scrooloose/nerdtree.git ~/.vim/bundle 此时~/.vim/bundle/nerdtree下应该有如下几个目录和文件 autoload doc lib nerdtree_plugin plugin README.markdown syntax 这几个目录是vim默认的插件目录，如果我们不是通过pathogen加载插件，就需要在~/.vim目录下创建对应的这几个目录，并将NERDTree对应的文件拷到相应的目录，这样每个目录下会放置多个插件的内容，比如~/.vim/doc下就会放置所有插件的帮组文档，而我们通过pathogen来管理，每个插件的所有内容都放在同一个目录中，比如这里的NERDTree插件的内容我们下载到了~/.vim/bundle/nerdtree下，直接删除这个目录即可删除插件，如果后续插件有更新，在该目录下通过git命令也可以很容易更新到最新版本。 打开vim，在命令行模式下输入:Helptags载入插件的帮组文档，或者用:helptags help_dir载入指定目录的帮组文档，其中help_dir是你需要加载的插件帮组文档所在的目录，比如这里是~/.vim/bundle/nerdtree/doc 测试 用vim打开一个文件，在命令行模式下输入:NERDTree，然后回车，窗口左侧就出现了vim工作目录的目录树，如下图所示 将光标置于NERDTree窗口，按'?'可查看帮助，NERDTree的操作很简单，通常是将光标置于一个目录/文件上，通过一个按键来操作，下面列出几个常用按键及其对应的操作 文件相关操作 o : 在光标所在的上一个窗口打开文件，并将光标置于新打开的窗口 go : 预览文件，光标停留在NERDTree窗口中 t : 在新标签中打开文件并激活 gt : 在新标签打开文件，光标留在NERDTree窗口中 i : 水平分割打开文件 gi : 水平分割预览 s : 垂直分割打开文件 gs : 垂直分割预览 目录树相关操作 o : 展开/关闭目录 O : 递归展开目录。慎用，如果目录层级多，打开会很慢 x : 关闭父目录 C : 切换光标所在目录为根目录 u : 切换目录树的根目录为上层目录 U : 切换目录树的根目录为上层目录，并保持旧的目录树的状态 r : 刷新当前目录 R : 刷新当前根目录（这个在新加入文件后会用到） cd : 切换vim工作目录为光标所在目录（命令模式下:pwd可查看当前工作目录） 为了方便打开NERDTree，我们可以设置快捷键，打开~/.vimrc，插入如下一行 map <C-n> :NERDTree<CR> 这样，当打开vim时，只要输入ctrl+n即可打开NERDTree MiniBufExplorer 项目地址 http://www.vim.org/scripts/script.php?script_id=159 功能 显示已打开的buffer 安装 以6.3.2版本为例，根据项目地址可以找到对应版本的下载链接 mkdir -p ~/.vim/bundle/minibufexplorer/plugin && wget \"http://www.vim.org/scripts/download_script.php?src_id=3640\" -O ~/.vim/bundle/minibufexplorer/plugin/minibufexpl.vim 测试 用vim打开一个文件，此时看不到minibufexplorer窗口，因为默认是只有一个buffer时不显示窗口的，在命令行模式下通过 :vsp filename 打开另一个文件（或者用NERDTree浏览打开其它文件），看看此时窗口上方是不是出现了MiniBufExplorer的窗口，如下所示 我们先来解释一下什么叫buffer，vim为每个打开的文件都创建了一个buffer，这个buffer存储在内存中，为了下次打开文件时快速加载，比如我们通过NERDTree浏览并打开了多个文件，即便某些文件你退出了编辑，它的buffer仍旧是存在的，在命令模式下，我们输入 :ls 可以查看打开的buffer列表，每一行前面的数字对应buffer的编号，通过输入 :b N ，其中N代表buffer编号，可以打开对应的buffer。对应上面的截图，我们打开了两个文件，此时minibufexplorer窗口显示有两个buffer，即便我们关闭一个文件，这两个buffer仍然存在，将光标移到某个buffer的名称上，回车可打开对应的buffer，按 d 可删除buffer，具体的操作可以直接阅读插件文件，路径为~/.vim/bundle/minibufexplorer/plugin/minibufexpl.vim 配置 在~/.vimrc文件中加入如下命令 let g:miniBufExplMaxSize = 2 该配置含义为minibufexplorer窗口最大高度为2行，默认是没有上限的，你打开的buffer足够多，一会一直增长下去，为了方便阅读我一般将它设为2，其它配置不怎么用到，需要用的时候可以参考插件文件，并在~/.vimrc中添加配置 ctags+taglist+omnicppcomplete 接下来就到了重磅戏了，前面还只是一些窗口相关的基本操作，是为了方便浏览文件，我们阅读C++代码时希望能快速定位函数、变量，类似于VS等其它IDE提供的功能 ctags 这个并不是插件，而是可执行程序，是用来对代码建索引，方便查找的，有些Linux版本是自带ctags的，如果没有，按如下方式安装 sudo yum install ctags ubuntu安装方式 sudo apt-get install ctags mac也是自带ctags的，但是那个不好用，可以重新安装 brew install ctags 如果安装失败，看是不是因为/usr/bin/ctags文件已经存在，可以先mv走，然后再执行 创建索引：在你代码的根目录执行如下命令，会生成一个tags文件，此时在代码根目录下打开一个文件（vim默认只加载工作目录下的tags文件），将光标置于一个函数或结构体名字上，按 ctr+] 即可跳转到该名称的定义处，如果出现多个选项，可以输入编号选择对应跳转的地方，按 ctr+o 可回到光标之前的位置 ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ taglist taglist是vim的一个插件，可以将代码内的函数、变量等按规律列出来，方便查找 下载地址 http://www.vim.org/scripts/script.php?script_id=273 ，或者直接按如下方式下载并安装 cd ~/.vim/bundle && wget \"http://www.vim.org/scripts/download_script.php?src_id=19574\" -O taglist.zip && unzip taglist.zip -d taglist 这样就生成了~/.vim/bundle/taglist目录，该目录的结构为 taglist ├── doc │ └── taglist.txt └── plugin └── taglist.vim 其中plugin目录下为插件文件，doc目录下为说明文档。打开vim，在命令行模式下输入 :helptags ~/.vim/bundle/taglist/doc 可以加载说明文档，然后输入 help taglist.txt 则可以显示说明文档 配置 打开~/.vimrc，输入如下内容 let Tlist_Show_One_File=1 \" 只展示一个文件的taglist let Tlist_Exit_OnlyWindow=1 \" 当taglist是最后以个窗口时自动退出 let Tlist_Use_Right_Window=1 \" 在右边显示taglist窗口 let Tlist_Sort_Type=\"name\" \" tag按名字排序 这几行配置看名字就能知道什么意思，引号后边是说明，在vim配置文件里，双引号代表注释，类似于C语言里的/ 测试 打开一个文件，在命令行模式下输入 :TlistToggle 即可显示taglist窗口，配合NERDTree一起效果如下 OmniCppComplete 这是一个对C++进行语法补全的插件，可以对函数、命名空间、类成员等进行补全，使用起来和绝大多数IDE差不多，不一样的是IDE为你做了很多你不知道的事情，而omni补全需要依赖tags文件，需要你用ctags命令自己生成 下载地址 http://www.vim.org/scripts/script.php?script_id=1520 也可用如下命令直接下载并安装 cd ~/.vim/bundle && wget \"http://www.vim.org/scripts/download_script.php?src_id=7722\" -O omnicppcomplete.zip && unzip omnicppcomplete.zip -d omnicppcomplete 该命令会生成~/.vim/bundle/omnicppcomplete目录，目录结构为 ├── after │ └── ftplugin │ ├── cpp.vim │ └── c.vim ├── autoload │ └── omni │ ├── common │ │ ├── debug.vim │ │ └── utils.vim │ └── cpp │ ├── complete.vim │ ├── includes.vim │ ├── items.vim │ ├── maycomplete.vim │ ├── namespaces.vim │ ├── settings.vim │ ├── tokenizer.vim │ └── utils.vim └── doc └── omnicppcomplete.txt 打开vim，在命令行模式下输入 :helptags ~/.vim/bundle/omnicppcomplete/doc 即可加载说明文档，输入 :help omnicppcomplete 查看说明文档 配置 打开~/.vimrc文件，输入 filetype plugin indent on set completeopt=longest,menu let OmniCpp_NamespaceSearch = 2 \" search namespaces in the current buffer and in included files let OmniCpp_ShowPrototypeInAbbr = 1 \" 显示函数参数列表 let OmniCpp_MayCompleteScope = 1 \" 输入 :: 后自动补全 let OmniCpp_DefaultNamespaces = [\"std\", \"_GLIBCXX_STD\"] 测试 前面说过，omni插件的补全是依赖于tags文件的，因此需要我们手动建立tags文件，假设现在有两个文件hello.h和hello.cpp如下 我们在和这两个文件所在的目录输入 ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ 这样就生成了tags文件，然后我们打开main.cpp来测试，当输入hello.h和hello.cpp中的函数或结构体时，通过按 ctr+x ctr+o 就可以自动补全了，效果如下 通过按ctr+n和ctr+p可以对候选项进行上下选择。通过这种方式可以实现对函数、结构体的补全 对STL补全 上面的方式只能对自己的代码进行补全，是当我们要使用其它库比如STL甚至是第三方库时就无法补全，原因很简单，我们只对自己的代码建立了tags文件，想要对其它库进行补全，就必须对它们的源代码建立tags文件，所幸的是vim的插件编写者们早已解决了这个需求，并且他们专门针对STL头文件进行了修改，以便能更好的适应omni的补全，首先下载STL源代码，地址为 http://www.vim.org/scripts/script.php?script_id=2358 ，可通过如下命令下载并解压 mkdir -p ~/.vim/tags && cd ~/.vim/tags && wget \"http://www.vim.org/scripts/download_script.php?src_id=9178\" -O - | tar jxvf - 这样就将STL的源码下载到了~/.vim/tags/cpp_src目录下，我们在该目录下执行ctags命令 ctags -R --sort=yes --c++-kinds=+p --fields=+iaS --extra=+q --language-force=C++ 这样就生成了~/.vim/tags/cpp_src/tags这个文件，然后打开~/.vimrc进行如下设置 set tags+=~/.vim/tags/cpp_src/tags 该命令是设置tags文件的搜索路径，默认只有vim工作目录的tags文件，这样设置之后就会同时加载指定目录的tags文件，你可以在后面添加更多其它第三方库的tags文件，现在对STL的补全效果如下 omnicppcomplete的补全设置虽然麻烦，但也让我们更加清楚了插件是怎样工作的，作为程序员，至少应该对某些东西的工作原理搞清楚，而不是像使用IDE一样不管任何东西，你想自定义一下东西也无从下手。 omnicppcomplete触发补全需要用到 ctr+x ctr+o ，显然这是不友好的，熟悉Linux命令行的人一定对shell命令的补全印象深刻，只需要按一下TAB键就可以进行补全，vim插件的强大之处在于，它可以实现你几乎所有的需求，想要用TAB键进行补全，就需要用到SuperTab SuperTab 项目地址 https://github.com/ervandew/supertab 安装 使用git进行安装是最方便的 cd ~/.vim/bundle && git clone https://github.com/ervandew/supertab.git 测试 无需任何配置即可使用，这时你想要补全变量名或函数名只需按一下TAB键即可，出现候选窗口之后也可以用TAB键进行选择，这样是不是方便了很多！ 由于TAB键被映射成了补全快捷键，也就无法通过TAB键直接输入制表符，这时如果想要输入制表符可以通过 ctr+v TAB 即可，即先输入ctr+v再输入TAB键，在vim下通过ctl+v可以输入很多不可见字符，比如试试 ctr+v ctr+w 最终的配置文件 装了这么多插件，在配置文件~/.vimrc里也增添了不少内容，最后你的配置文件至少应该包含以下内容 set tags+=~/.vim/tags/cpp_src/tags \" 设置tags搜索路径 syntax on filetype plugin indent on map <C-n> :NERDTree<CR> \" pathongen execute pathogen#infect() \" taglist let Tlist_Show_One_File=1 let Tlist_Exit_OnlyWindow=1 let Tlist_Use_Right_Window=1 let Tlist_Sort_Type=\"name\" \" omnicppcomplete set completeopt=longest,menu let OmniCpp_NamespaceSearch = 2 \" search namespaces in the current buffer and in included files let OmniCpp_ShowPrototypeInAbbr = 1 \" 显示函数参数列表 let OmniCpp_MayCompleteScope = 1 \" 输入 :: 后自动补全 let OmniCpp_DefaultNamespaces = [\"std\", \"_GLIBCXX_STD\"] 这个配置文件全都是和插件相关的配置，你还可以在里面添加其它配置来灵活定制你的vim，由于本文主要介绍插件相关内容，就不展开介绍了 总结 vim的C++开发环境到此就配好了，总的来说我们安装了这么几类插件 管理插件的插件 管理窗口和buffer 语法增强 代码补全 通过这些插件我们可以将vim打造成一个好用的IDE，虽然经过了很多周折，但这些功夫都不会白费，一来我们可以通过这些插件了解IDE的一些工作原理，二来通过这些插件的安装我们也更加了解了vim插件的使用方法，有了这些基础，后续如果想满足一些个性化的需求，岂不易哉！","tags":"Skill","title":"Vim c++开发环境插件安装详解"},{"url":"http://localhost:8000/c++实战——多人会话聊天室.html","text":"无他，但手熟尔 ——《卖油翁》 任何一门编程语言，要想熟练，唯有多练。即便是读了一千本小说，若不自己写文章，也成不了作家，编程技术更是需要日复一日反复练习，我将自己学习C++过程中的练习经历与大家分享，如果能给其他初学者以帮助，那是最让人感到欣慰的，当然，本人也是初学者，不足之处难免，望高手多多指教 功能概述 === 多人会话聊天室的练习起源于学习多线程和socket编程，服务端和客户端的大致功能如下： 服务端进程代表一个聊天室，响应多个客户端的请求，客户端以用户名登陆之后，可以发表消息，服务端将消息推送给所有登陆的用户，类似于QQ的讨论组一样的功能 客户端向服务端发起连接，通过特定指令登陆，登陆之后可发表消息。客户端支持的指令包扩 login name, 以name为用户名登陆 look, 查看当前登陆的所有用户 logout, 退出当前用户 quit, 退出客户端 本文所有代码在Ubuntu和Mac OS X上编译运行通过，如果是windows用户不保证能编得过。 项目地址 https://github.com/handy1989/chatserver/tree/version1.0.1 实践分析 === 由于在实践过程中我只保留了最终可运行的版本，所以我这里只给出最终版本的源代码，一些中间状态的代码只会分析一下逻辑。毕竟任何程序都不是一开始就完成所有功能，我也是先从简单功能开始实现，然后一点一点添加。 小试牛刀 先看一下最简单的服务器客户端程序逻辑，这种源代码Google一下到处都是 服务端 1. 调用socket函数建立一个连接，返回一个文件描述符sockfd 2. 调用bind函数将sockfd和服务器地址绑定 3. 调用listen函数，使sockfd可以接受其它连接 4. 调用accept函数，接受客户端的连接，返回这个连接的文件描述符connfd 5. 调用send函数向connfd发送消息 6. 调用recv函数从connfd接受消息 客户端 客户端的逻辑就简单多了 1. 调用socket得到sockfd 2. 调用connect和sockfd建立连接 3. 调用send向sockfd发送消息 4. 调用recv从sockfd接受消息 以上函数具体用法在Linux下都可以通过man手册查到（比如man socket），虽然英文的阅读效率低一点，但绝对是最权威的 这里需要说明一下文件描述符的概念，在Linux下，所有设备、网络套接字、目录、文件，都以file的概念来对待，打开一个对象就会返回一个文件描述符，通过文件描述符就可以实际的去操作对象，比如read, write, close等。其中最典型的文件描述符就是0、1、2，分别代表标准输入、标准输出、标准错误 。 从上面可以看出服务器端和客户端的区别，服务端先创建一个文件描述符sockfd，这个是负责接受客户端的连接请求的，当客户端请求成功后服务端会得到这个连接的一个专属文件描述符connfd，如果有多个客户端，那么这多个客户端的connfd都是不同的，服务端和客户端的消息读写都是通过connfd进行，而客户端和服务端的消息读写都是通过sockfd进行。 客户端实现 客户端逻辑很简单，先建立连接，然后收发消息。但要注意一点，客户端的收发消息并不是同步的，也就是说并不是发一条就收一条，由于是多人会话，即便你不发消息，也有可能收到别人的消息，所以这里需要将收消息和发消息分离，这里我们用多线程来实现，一个线程专门负责接收消息，并将消息打印到屏幕上，一个线程专门读取标准输入，将消息发送出去。 客户端代码见 https://github.com/handy1989/chatserver/blob/version1.0.1/client.cpp 服务端实现 根据文章开始给出的服务端功能，我们画出服务端的处理流程图 我们在服务端对每个连接建立一个线程，由线程来单独管理和客户端的通信，线程里的处理逻辑就和最简单的服务器客户端模型一样，先接收客户端消息，再给客户端返回信息，不过由于是多人会话，每个客户端发表一条消息，服务端需要给其它所有用户推送消息，这就需要服务端记录登陆进来的所有用户，为了简化，我没有设置密码，并且每次服务端重启后，所有用户信息清零 服务端的数据结构见文件 https://github.com/handy1989/chatserver/blob/version1.0.1/chatserver.h ，下面分别说明几个关键变量 std : :map < int , std : :string > m_users ; std : :set < std : :string > s_users ; m_users用来存储和客户端连接的文件描述符与用户名的对应关系，s_users存储的是所有登陆的用户，也就是m_users的value的集合，为很么还要设置一个s_users呢，因为每次用户登陆的时候需要查找用户是否已注册，而m_users是以文件描述符为key的，查value是否存在不太好操作，于是就将value单独存储起来，便于查找 int connfd_arr[MAX_THREAD_NUM]; connfd_arr存储的时当前连接的文件描述符，设置了一个最大连接数，当有用户连接时，如果连接数超过了最大值，服务端将不会建立线程去通信，否则，服务端会从数组里找一个未被占用的分配给该连接，当线程退出时，数组对应的值会置为-1 typedef void ( ChatServer ::* p_func )( char * arg , bool & is_logged , int connfd , ChatServer * p_session , std : :string & user_name ); std : :map < std : :string , p_func > m_func ; 由于服务端需要根据用户输入的消息来调用相应处理函数，比如login name对应的登录函数，look对应查看用户的函数，所以服务端需要根据字符串去调用一个函数，最简单的实现就是写若干个if语句一一比较，但我们用了一种更优雅的方式，首先我们将所有处理函数定义成一样的类型，也就是参数和返回值都一样，然后定义一个map型变量，key为命令的关键字，如\"login\"\"logout\"等等，value就是对应的处理函数的地址，这样我们接收到客户端的消息后，解析出是哪种命令，然后直接查找map得到函数地址，就可以调用对应函数了 服务端和客户端完整代码见 https://github.com/handy1989/chatserver/tree/version1.0.1 ，客户端运行之后的效果如下 这里只是演示了一个用户登录的情况，感兴趣的可以多个客户端同时连接看看效果 小结 === 本文实现了多人会话的基本功能，服务端通过线程与客户端建立连接，并且自己管理线程，为了简单，线程同步等因素都没有考虑进去。这样做只是为了能尽快对网络通信有个感性的认识，咱又不是想把它做成产品，能运行起来就是最终目的。但是明显的缺陷也摆在这里，比如多线程的管理，accept的阻塞等等，下次将会分享一个基于epoll模型的多人会话聊天室，有了epoll的管理，服务端的代码将会变得清晰而又简洁","tags":"Language","title":"c++实战——多人会话聊天室"},{"url":"http://localhost:8000/c++实战——多人会话聊天室（二）.html","text":"前面已经讲过一次多人会话聊天室的实现 C++实战——多人会话聊天室（一） ，只不过上一篇是用最简单的方式，服务端每接收一个连接就起一个线程，而且是阻塞模式的，也就是说服务端每次调用accept函数时会一直等待有客户端连接上才会返回。今天介绍一种基于epoll模型的非阻塞方式的实现。 === 阻塞与非阻塞 顾名思义，阻塞就是当你调用一个函数后它会一直等在那里，知道某个信号叫醒它，最典型的例子就是read之类的函数，当你调用时它会等待标准输入，直到你在屏幕上输完敲下回车，它才会继续执行。Linux默认IO都是阻塞模型的 非阻塞就是当你调用函数之后它会立马返回，同样还是拿read举例，它不会阻塞在屏幕上等待你输入，而是立马返回，如果返回错误，那就代表没有数据可读。下面的例子可以大致说明一下差别 #include <unistd.h> #include <stdio.h> #include <fcntl.h> #include <stdlib.h> int main ( int argc , char * argv []) { int res ; res = fcntl ( 0 , F_GETFL ); if ( - 1 == res ) { perror ( \"fcntl error!\" ); exit ( 1 ); } #ifdef NONBLOCK res |= O_NONBLOCK ; if ( fcntl ( 0 , F_SETFL , res ) == - 1 ) { perror ( \"error\" ); exit ( 1 ); } #endif char buf [ 100 ]; int n = 0 ; n = read ( 0 , buf , 100 ); if ( - 1 == n ) { perror ( \"read error\" ); exit ( 1 ); } else { printf ( \"read %d characters \\n \" , n ); } return 0 ; } 代码的意思很好理解，我们从标准输入读取数据，并打印出读取了多少字节，但是我们做了个测试，当定义了宏NONBLOCK后，我们会将标准输入句柄改变成非阻塞的，宏可以通过编译时的-D参数指定，我们分别按如下指令编译，假设文件名为test.cpp g++ test.cpp -o test_block g++ test.cpp -D NONBLOCK -o test_nonblock 然后我们运行./test_block，程序会阻塞在屏幕上等待输入，输入hello world并回车，程序运行结束 但是当我们运行./test_nonblock时，程序报错 read error: Resource temporarily unavailable ，这是因为此时的标准输入是非阻塞模式，当调用read后它会立马返回，而此时并没有数据可读取，就会返回错误，但是我们按如下方式就可运行成功 echo \"hello world\" | ./test_nonblock 因为在read调用之前，管道里已经有了数据，所以它会去读取管道里的数据而不会出错。 to be continued...","tags":"Language","title":"c++实战——多人会话聊天室（二）"},{"url":"http://localhost:8000/curl参数说明.html","text":"参数 说明 -i/--include 输出响应包头 -I 只获取响应包头 -x/—proxy 设置代理 -X/—request 设置http method -D/—dump-header 输出包头到指定文件 -H/--header 指定请求包头字段 如果有多个字段，可多次使用本参数 -d/—data 发送post数据(ascii) curl -d \"param1=value1&param2=value2\" --data-binary —data-binary '@filename' 发送二进制post数据 如果以'@'开头则发送文件内容 -A/—user-agent 设置user-agent","tags":"Skill","title":"curl参数说明"},{"url":"http://localhost:8000/extern “C”用法详解.html","text":"今天是接着昨天谈extern的用法，纯技术贴。目前用户数以每天1-2的数量在增长，突破100不知何时到头啊，不过昨天的文章阅读数竟然超过了用户数，看来宣传宣传还是有用的，而且看到有更多人阅读，也给了我更大写作的动力，于是我决定不定期的在这里发放小米F码！周围有朋友有需求的赶紧号召过来关注哇，不过数量有限，每次发放一个，我会提前一天预告，第二天文章推送时将F码奉上，如果你看到F码并且也需要，请赶紧使用，不然有可能被别人抢走的哦&#94;_&#94; ，明天要发放的F码是 米4联通3G版 简单来说，extern \"C\"是C++声明或定义C语言符号的方法，是为了与C兼容。说来容易，要理解起来还是得费些周折，首先我们要从C++和C的区别说起。 符号 大家都知道，从代码到可执行程序需要经过编译和链接两个过程，其中编译阶段会做语法检测，代码展开，另外它还会做一件事，就是将变量转成符号，链接的时候其实是通过符号来定位的。编译器在编译C和C++代码时，将变量转成符号的过程是不同的。本文所使用的编译器为gcc4.4.7 我们先来看一段简单的代码 /* hello.c */ #include <stdio.h> const char * g_prefix = \"hello \" ; void hello ( const char * name ) { printf ( \"%s%s\" , g_prefix , name ); } 注意，这里的文件名为hello.c，我们执行编译 gcc -c hello.c 得到目标文件hello.o，在Linux下用nm查看目标文件的符号表得到如下结果( $ 符号代表shell命令提示符) $ nm hello.o 0000000000000000 D g_prefix 0000000000000000 T hello U printf 这是C代码编译后的符号列表，其中第三列为编译后的符号名，我们主要看自己定义的全局变量g_prefix和函数hello，它们的编译后的符号名和代码里的名字是一样的。我们将hello.c重命名为hello.cpp，重新编译 gcc -c hello.cpp 得到hello.o，在用nm查看，结果如下 0000000000000000 T _Z5helloPKc U __gxx_personality_v0 0000000000000000 D g_prefix U printf 这是C++代码编译后的符号列表，gcc会自动根据文件后缀名来识别C和C++代码，这时我们发现g_prefix的符号没变，但函数hello的符号变成了 _Z5helloPKc ，这就说明gcc在编译C和C++代码时处理方式是不一样的，对于C代码，变量的符号名就是变量本身（在早期编译器会为C代码变量前加下划线 _ ，现在默认都不会了，在编译时可以通过编译选项 -fno-leading-underscore 和 -fleading-underscore 来显式设置），而对于C++代码，如果是数据变量并且没有嵌套，符号名也是本身，如果变量名有嵌套（在名称空间或类里）或者是函数名，符号名就会按如下规则来处理 1、 符号以 _Z 开始 2、 如果有嵌套，后面紧跟 N ，然后是名称空间、类、函数的名字，名字前的数字是长度，以 E 结尾 3、 如果没嵌套，则直接是名字长度后面跟着名字 4、 最后是参数列表，类型和符号对应关系如下 int -> i float -> f double -> d char -> c void -> v const -> K * -> P 这样就很好理解为什么C++代码里的void hello(const char*)编译之后符号为_Z5helloPKc（PKc翻译成类型要从右到左翻译为 char const * ，这是编译器内部的表示方式，我们习惯的表示方式是 const char* ，两者是一样的）， c++filt 工具可以从符号反推名字，使用方法为 c++filt _Z5helloPKc 下面列举几个函数和符号的对应例子 函数和变量 符号 int func(int, int) _Z4funcii float func(float) _Z4funcf int C::func(int) _ZN1C4funcEi int C::C2::func(int) _ZN1C2C24funcEi int C::var _Z1C3varE 这样也很容易理解为什么C++支持函数重载而C不支持了，因为C++将函数修饰为符号时把函数的参数类型加进去了，而C却没有，所以在C++下，即便函数名相同，只要参数不同，它们的符号名是不会冲突的。我们可以通过下面一个例子来验证变量名和符号的这种关系 / * filename : test . cpp */ #include <stdio.h> namespace myname { int var = 42 ; } extern int _ZN6myname3varE ; int main () { printf ( \"%d \\n \" , _ZN6myname3varE ); return 0 ; } 这里我们在名称空间namespace定义了全局变量var，根据前面的内容，它会被修饰为符号 _ZN6myname3varE ，然后我们手动声明了外部变量 _ZN6myname3varE 并将其打印出来。编译并运行，它的值正好就是var的值 $ gcc test.cpp -o test -lstdc++ $ ./test 42 extern \"C\" 有了符号的概念我们再来看extern \"C\"的用法就很容易了 extern \"C\" { int func(int); int var; } 它的意思就是告诉编译器将extern \"C\"后面的括号里的代码当做C代码来处理，当然我们也可以以单条语句来声明 extern \"C\" int func(int); extern \"C\" int var; 这样就声明了C类型的func和var。很多时候我们写一个头文件声明了一些C语言的函数，而这些函数可能被C和C++代码调用，当我们提供给C++代码调用时，需要在头文件里加extern \"C\"，否则C++编译的时候会找不到符号，而给C代码调用时又不能加extern \"C\"，因为C是不支持这样的语法的，常见的处理方式是这样的，我们以C的库函数memset为例 #ifdef __cplusplus extern \"C\" { #endif void * memset ( void * , int , size_t ); #ifdef __cplusplus } #endif 其中 __cplusplus 是C++编译器定义的一个宏，如果这份代码和C++一起编译，那么memset会在extern \"C\"里被声明，如果是和C代码一起编译则直接声明，由于 __cplusplus 没有被定义，所以也不会有语法错误。这样的技巧在系统头文件里经常被用到。 点击阅读原文查看我的博客，如果觉得本文有价值，请为我点个赞，或者为我增加一个读者","tags":"Language","title":"extern \"C\"用法详解"},{"url":"http://localhost:8000/http缓存服务器淘汰策略.html","text":"根据设计需求，一共有三级缓存，分别是内存，SSD，磁盘，所以缓存资源淘汰路径可以是 内存 -> SSD SSD -> 硬盘 硬盘 -> 删除 也会有资源的优先级提升，比如从磁盘提升到SSD或内存。这三种缓存资源可采用同一个优先级队列来管理，新增一个资源时先计算其优先级，得到其在优先级队列中的位置，通过位置可决定存储到哪种媒介，同样，当访问资源时更新其优先级即其在队列中的位置，如果该位置对应的媒介发生变化，则需要做资源的迁移，并且在迁移时可能对目的媒介做调整以满足迁移需求。 具体有哪些存储媒介涉及具体实现，淘汰算法本身不关心这些，淘汰算法要做的只是调整资源在优先级队列中的位置，至于调整之后的操作则由业务层去负责，因此下面只针对淘汰算法本身来讨论 LRU 最常见也是实现最简单的策略就是LRU（Least Recently Used，最近最少使用）算法，根据数据的历史访问记录来进行淘汰数据，其核心思想是\"如果数据最近被访问过，那么将来被访问的几率也更高\" LRU一般采用双向链表实现，基本结构如下 struct LruNode { LruNode* prev; LruNode* next; void* data; }; struct LruList { LruNode* head; LruNode* tail; }; LruNode中的data成员即指向实际缓存索引数据，假设缓存索引以hash结构表示，则淘汰链结构可设计如下 这样hash结构和LRU链表结构分离，分别持有对方指针。下面考虑资源的三种操作 删除节点 假设删除key2，先通过key2查找到ValueObject，得到指向LruNode的指针，删除该节点即可，时间复杂度O(1) 新增节点 新增节点直接加入LruList头部，时间复杂度O(1)如下 新增节点可能会导致缓存达到上限，比如限定内存缓存上限2G，新增一个内存缓存后会操过2G，则需要删除一些资源腾出空间，此时只需要从LruList尾部开始遍历，依次删除直到内存满足需求为止，时间复杂度O(M)，M为需要删除的节点个数。假设加入节点key5时需要删除key1，则结构如下 访问节点 在LRU算法中，一个节点被访问后只需将该节点移动到链表头即可，时间复杂度O(1)，假设访问key4，则结构如下 LRU优缺点 优点：实现简单 缺点：当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重 抽象 前面主要描述了LRU算法结合hash索引的各种操作，实际上任何一个淘汰策略模型都可以被抽象为一个有序队列，每个节点持有一个value，这个value由具体的函数计算得到，队列根据value排序，这样，淘汰策略模型具体操作可描述如下 添加节点： 计算节点value，插入队列，并对队列重新排序 删除指定节点： 将节点从队列中删除 访问节点： 重新计算该节点value，并对队列重新排序 淘汰节点： 从value最小的节点开始依次淘汰 模型的关键在于保持队列有序和计算节点vlaue值，假设我们已经有一个模型能满足基本的插入删除等操作，并保持队列有序，我们只需要实现不同的value计算函数即可实现不同的淘汰算法 以LRU为例，其value计算函数可描述为 $$ V_i = LatestRefTime $$ 即节点最近访问时间，每次访问节点均更新时间，这样新添加和最近被访问的节点优先级最高 基于这种抽象模型，下面介绍几种其它淘汰策略 squid淘汰策略 除了LRU以外，squid还实现了另外两种淘汰策略，这两种策略均可减少LRU缓存污染的缺点，并针对资源命中率和资源字节命中率做了优化 GDSF GDSF（GreddyDual-Size with Frequency）会同时考虑资源访问频次和资源大小，越小的文件被缓存的可能性越大，因此该算法可提高资源命中率，其value计算函数描述如下 $$ V_i = F_i * C_i/S_i + L$$ \\( V_i \\) 代表对象\\( i \\)计算的value值 \\( F_i \\) 代表对象的访问频次 \\( C_i \\) 代表将对象加入缓存的开销，根据squid论文，该值取1时效果最佳 \\( S_i \\) 代表对象大小 \\( L \\) 为动态age，随着对象的加入而递增 LFU-DA LFU-DA（Least Frequently Used with Dynamic Aging）是基于LFU（Least Frequently Used）增加了动态age，它更倾向于缓存被访问频次大的对象，而不论对象大小是多少，因此它可以获得更大的资源字节命中率，其value计算函数描述如下 $$ V_i = C_i * F_i + L$$ \\( V_i \\) 代表对象\\( i \\)计算的value值 \\( F_i \\) 代表对象的访问频次 \\( C_i \\) 代表将对象加入缓存的开销 \\( L \\) 为动态age，随着对象的加入而递增 当\\( C_i \\) 取值为1时，该算法等价于在LFU基础上添加动态age squid中均有以上两种策略的实现，均采用heap管理，只是提供不同计算value的函数 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Skill","title":"http缓存服务器淘汰策略"},{"url":"http://localhost:8000/libevent evhttp学习——http客户端.html","text":"基本环境 使用版本为libevent-2.1.5，目前为beta版，其中evhttp和旧版区别在于新增了如下接口 // 设置回调函数，在包头读取完成后回调 void evhttp_request_set_header_cb ( struct evhttp_request * , int ( * cb )( struct evhttp_request * , void * )) // 设置回调函数，在body有数据返回后回调 void evhttp_request_set_chunked_cb ( struct evhttp_request * , void ( * cb )( struct evhttp_request * , void * )) 这样的好处是可以在合适的时机回调我们注册的回调函数，比如下载1G的文件，在之前的版本只有下载完成后才会回调，现在每下载一部分数据就会回调一次，让上层应用更加灵活，尤其在http代理时，可以做到边下载边回复 2.1.5版本的完整接口文档详见 http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/http_8h.html 请求流程 http客户端使用到的接口函数及请求流程如下 初始化event_base和evdns_base struct event_base * event_base_new ( void ); struct evdns_base * evdns_base_new ( struct event_base * event_base , int initialize_nameservers ); 创建evhttp_request对象，并设置回调函数，这里的回调函数是和数据接收相关的 cpp struct evhttp_request *evhttp_request_new(void (*cb)(struct evhttp_request *, void *), void *arg); void evhttp_request_set_header_cb(struct evhttp_request *, int (*cb)(struct evhttp_request *, void *)); void evhttp_request_set_chunked_cb(struct evhttp_request *, void (*cb)(struct evhttp_request *, void *)); void evhttp_request_set_error_cb(struct evhttp_request *, void (*)(enum evhttp_request_error, void *)); 3. 创建evhttp_connection对象，并设置回调函数，这里的回调函数是和连接状态相关的 cpp struct evhttp_connection *evhttp_connection_base_new(struct event_base *base, struct evdns_base *dnsbase, const char *address, unsigned short port); void evhttp_connection_set_closecb(struct evhttp_connection *evcon, void (*)(struct evhttp_connection *, void *), void *); 4. 有选择的向evhttp_request添加包头字段 cpp int evhttp_add_header(struct evkeyvalq *headers, const char *key, const char *value); 5. 发送请求 cpp int evhttp_make_request(struct evhttp_connection *evcon, struct evhttp_request *req, enum evhttp_cmd_type type, const char *uri); 6. 派发事件 cpp int event_base_dispatch(struct event_base *); 完整代码 #include \"event2/http.h\" #include \"event2/http_struct.h\" #include \"event2/event.h\" #include \"event2/buffer.h\" #include \"event2/dns.h\" #include \"event2/thread.h\" #include <stdio.h> #include <string.h> #include <assert.h> #include <sys/queue.h> #include <event.h> void RemoteReadCallback ( struct evhttp_request * remote_rsp , void * arg ) { event_base_loopexit (( struct event_base * ) arg , NULL ); } int ReadHeaderDoneCallback ( struct evhttp_request * remote_rsp , void * arg ) { fprintf ( stderr , \"< HTTP/1.1 %d %s \\n \" , evhttp_request_get_response_code ( remote_rsp ), evhttp_request_get_response_code_line ( remote_rsp )); struct evkeyvalq * headers = evhttp_request_get_input_headers ( remote_rsp ); struct evkeyval * header ; TAILQ_FOREACH ( header , headers , next ) { fprintf ( stderr , \"< %s: %s \\n \" , header -> key , header -> value ); } fprintf ( stderr , \"< \\n \" ); return 0 ; } void ReadChunkCallback ( struct evhttp_request * remote_rsp , void * arg ) { char buf [ 4096 ]; struct evbuffer * evbuf = evhttp_request_get_input_buffer ( remote_rsp ); int n = 0 ; while (( n = evbuffer_remove ( evbuf , buf , 4096 )) > 0 ) { fwrite ( buf , n , 1 , stdout ); } } void RemoteRequestErrorCallback ( enum evhttp_request_error error , void * arg ) { fprintf ( stderr , \"request failed \\n \" ); event_base_loopexit (( struct event_base * ) arg , NULL ); } void RemoteConnectionCloseCallback ( struct evhttp_connection * connection , void * arg ) { fprintf ( stderr , \"remote connection closed \\n \" ); event_base_loopexit (( struct event_base * ) arg , NULL ); } int main ( int argc , char ** argv ) { if ( argc != 2 ) { printf ( \"usage:%s url\" , argv [ 1 ]); return 1 ; } char * url = argv [ 1 ]; struct evhttp_uri * uri = evhttp_uri_parse ( url ); if ( ! uri ) { fprintf ( stderr , \"parse url failed! \\n \" ); return 1 ; } struct event_base * base = event_base_new (); if ( ! base ) { fprintf ( stderr , \"create event base failed! \\n \" ); return 1 ; } struct evdns_base * dnsbase = evdns_base_new ( base , 1 ); if ( ! dnsbase ) { fprintf ( stderr , \"create dns base failed! \\n \" ); } assert ( dnsbase ); struct evhttp_request * request = evhttp_request_new ( RemoteReadCallback , base ); evhttp_request_set_header_cb ( request , ReadHeaderDoneCallback ); evhttp_request_set_chunked_cb ( request , ReadChunkCallback ); evhttp_request_set_error_cb ( request , RemoteRequestErrorCallback ); const char * host = evhttp_uri_get_host ( uri ); if ( ! host ) { fprintf ( stderr , \"parse host failed! \\n \" ); return 1 ; } int port = evhttp_uri_get_port ( uri ); if ( port < 0 ) port = 80 ; const char * request_url = url ; const char * path = evhttp_uri_get_path ( uri ); if ( path == NULL || strlen ( path ) == 0 ) { request_url = \"/\" ; } printf ( \"url:%s host:%s port:%d path:%s request_url:%s \\n \" , url , host , port , path , request_url ); struct evhttp_connection * connection = evhttp_connection_base_new ( base , dnsbase , host , port ); if ( ! connection ) { fprintf ( stderr , \"create evhttp connection failed! \\n \" ); return 1 ; } evhttp_connection_set_closecb ( connection , RemoteConnectionCloseCallback , base ); evhttp_add_header ( evhttp_request_get_output_headers ( request ), \"Host\" , host ); evhttp_make_request ( connection , request , EVHTTP_REQ_GET , request_url ); event_base_dispatch ( base ); return 0 ; } 编译 g++ http_client.cpp -I/opt/local/libevent-2.1.5/include -L/opt/local/libevent-2.1.5/lib -levent -g -o http_client 运行示例，这里只打印了包头字段 $ ./ http_client http :// www .qq.com >/ dev / null < HTTP / 1 .1 200 OK < Server : squid / 3 .4.3 < Content-Type : text / html ; charset = GB2312 < Cache-Control : max-age = 60 < Expires : Fri , 05 Aug 2016 08 :48:31 GMT < Date : Fri , 05 Aug 2016 08 :47:31 GMT < Transfer-Encoding : chunked < Connection : keep-alive < Connection : Transfer-Encoding <","tags":"Language","title":"libevent evhttp学习——http客户端"},{"url":"http://localhost:8000/libevent evhttp学习——http服务端.html","text":"http服务端相对客户端要简单很多，我们仍旧使用libevent-2.1.5版本，服务端接口和2.0版本没有区别 基本流程 http服务端使用到的借口函数及流程如下 创建event_base和evhttp cpp struct event_base *event_base_new(void); struct evhttp *evhttp_new(struct event_base *base); 绑定地址和端口 cpp int evhttp_bind_socket(struct evhttp *http, const char *address, ev_uint16_t port); 设置处理函数 cpp void evhttp_set_gencb(struct evhttp *http, void (*cb)(struct evhttp_request *, void *), void *arg); 派发事件循环 cpp int event_base_dispatch(struct event_base *); 完整代码 服务器接收到请求后打印URL，并返回一段文本信息 #include \"event2/http.h\" #include \"event2/event.h\" #include \"event2/buffer.h\" #include <stdlib.h> #include <stdio.h> void HttpGenericCallback ( struct evhttp_request * request , void * arg ) { const struct evhttp_uri * evhttp_uri = evhttp_request_get_evhttp_uri ( request ); char url [ 8192 ]; evhttp_uri_join ( const_cast < struct evhttp_uri *> ( evhttp_uri ), url , 8192 ); printf ( \"accept request url:%s \\n \" , url ); struct evbuffer * evbuf = evbuffer_new (); if ( ! evbuf ) { printf ( \"create evbuffer failed! \\n \" ); return ; } evbuffer_add_printf ( evbuf , \"Server response. Your request url is %s\" , url ); evhttp_send_reply ( request , HTTP_OK , \"OK\" , evbuf ); evbuffer_free ( evbuf ); } int main ( int argc , char ** argv ) { if ( argc != 2 ) { printf ( \"usage:%s port \\n \" , argv [ 0 ]); return 1 ; } int port = atoi ( argv [ 1 ]); if ( port == 0 ) { printf ( \"port error:%s \\n \" , argv [ 1 ]); return 1 ; } struct event_base * base = event_base_new (); if ( ! base ) { printf ( \"create event_base failed! \\n \" ); return 1 ; } struct evhttp * http = evhttp_new ( base ); if ( ! http ) { printf ( \"create evhttp failed! \\n \" ); return 1 ; } if ( evhttp_bind_socket ( http , \"0.0.0.0\" , port ) != 0 ) { printf ( \"bind socket failed! port:%d \\n \" , port ); return 1 ; } evhttp_set_gencb ( http , HttpGenericCallback , NULL ); event_base_dispatch ( base ); return 0 ; } 编译 g++ http-server.cpp -I/opt/third_party/libevent/include -L/opt/third_party/libevent/lib -levent -o http-server","tags":"Language","title":"libevent evhttp学习——http服务端"},{"url":"http://localhost:8000/python网页解析利器——BeautifulSoup.html","text":"python解析网页，无出BeautifulSoup左右，此是序言 安装 BeautifulSoup4以后的安装需要用eazy_install，如果不需要最新的功能，安装版本3就够了，千万别以为老版本就怎么怎么不好，想当初也是千万人在用的啊。安装很简单 wget \"http://www.crummy.com/software/BeautifulSoup/download/3.x/BeautifulSoup-3.2.1.tar.gz\" tar zxvf BeautifulSoup-3.2.1.tar.gz 然后把里面的BeautifulSoup.py这个文件放到你python安装目录下的site-packages目录下 site-packages是存放Python第三方包的地方，至于这个目录在什么地方呢，每个系统不一样，可以用下面的方式找一下，基本上都能找到 sudo find / -name \"site-packages\" -maxdepth 5 -type d 当然如果没有root权限就查找当前用户的根目录 find ~ -name \"site-packages\" -maxdepth 5 -type d 如果你用的是Mac，哈哈，你有福了，我可以直接告诉你，Mac的这个目录在/Library/Python/下，这个下面可能会有多个版本的目录，没关系，放在最新的一个版本下的site-packages就行了。使用之前先import一下 from BeautifulSoup import BeautifulSoup 使用 在使用之前我们先来看一个实例 现在给你这样一个页面 http://movie.douban.com/tag/%E5%96%9C%E5%89%A7 它是豆瓣电影分类下的喜剧电影，如果让你找出里面评分最高的100部，该怎么做呢 好了，我先晒一下我做的，鉴于本人在CSS方面处于小白阶段以及天生没有美术细菌，界面做的也就将就能看下，别吐 http://littlewhite.us/douban/xiju/ 接下来我们开始学习BeautifulSoup的一些基本方法，做出上面那个页面就易如反掌了 鉴于豆瓣那个页面比较复杂，我们先以一个简单样例来举例，假设我们处理如下的网页代码 < html > < head >< title > Page title </ title ></ head > < body > < p id = \"firstpara\" align = \"center\" > This is paragraph < b > one </ b > . </ p > < p id = \"secondpara\" align = \"blah\" > This is paragraph < b > two </ b > . </ p > </ body > </ html > 你没看错，这就是官方文档里的一个样例，如果你有耐心，看官方文档就足够了，后面的你都不用看 http://www.leeon.me/upload/other/beautifulsoup-documentation-zh.html 初始化 首先将上面的HTML代码赋给一个变量html如下，为了方便大家复制这里贴的是不带回车的，上面带回车的代码可以让大家看清楚HTML结构 html = ' <html><head><title> Page title </title></head><body><p id= \"firstpara\" align= \"center\" > This is paragraph <b> one </b> . </p><p id= \"secondpara\" align= \"blah\" > This is paragraph <b> two </b> . </p></body></html> ' 初始化如下： soup = BeautifulSoup(html) 我们知道HTML代码可以看成一棵树，这个操作等于是把HTML代码解析成一种树型的数据结构并存储在soup中，注意这个数据结构的根节点不是 ，而是soup，其中html标签是soup的唯一子节点，不信你试试下面的操作 print soup print soup.contents[0] print soup.contents[1] 前两个输出结果是一致的，就是整个html文档，第三条输出报错IndexError: list index out of range 查找节点 查找节点有两种反回形式，一种是返回单个节点，一种是返回节点list，对应的查找函数分别为find和findAll 单个节点 根据节点名 ## 查找head节点 print soup.find('head') ## 输出为 <head><title> Page title </title></head> ## or ## head = soup.head 这种方式查找到的是待查找节点最近的节点，比如这里待查找节点是soup，这里找到的是离soup最近的一个head（如果有多个的话） 根据属性 ## 查找id属性为firstpara的节点 print soup.find(attrs={'id':'firstpara'}) ## 输出为 <p id= \"firstpara\" align= \"center\" > This is paragraph <b> one </b> . </p> ## 也可节点名和属性进行组合 print soup.find('p', attrs={'id':'firstpara'}) ## 输出同上 根据节点关系 节点关系无非就是兄弟节点，父子节点这样的 p1 = soup.find(attrs={'id':'firstpara'}) ## 得到第一个p节点 print p1.nextSibling ## 下一个兄弟节点 ## 输出 <p id= \"secondpara\" align= \"blah\" > This is paragraph <b> two </b> . </p> p2 = soup.find(attrs={'id':'secondpara'}) ## 得到第二个p节点 print p2.previousSibling ## 上一个兄弟节点 ## 输出 <p id= \"firstpara\" align= \"center\" > This is paragraph <b> one </b> . </p> print p2.parent ## 父节点，输出太长这里省略部分 <body> ... </body> print p2.contents[0] ## 第一个子节点，输出u'This is paragraph' contents上面已经提到过，它存储的是所有子节点的序列 多个节点 将上面介绍的find改为findAll即可返回查找到的节点列表，所需参数都是一致的 根据节点名 ## 查找所有p节点 soup.findAll('p') 根据属性查找 ## 查找id=firstpara的所有节点 soup.findAll(attrs={'id':'firstpara'}) 需要注意的是，虽然在这个例子中只找到一个节点，但返回的仍是一个列表对象 上面的这些基本查找功能已经可以应付大多数情况，如果需要各个高级的查找，比如正则式，可以去看官方文档 获取文本 getText方法可以获取节点下的所有文本，其中可以传递一个字符参数，用来分割每个各节点之间的文本 ## 获取head节点下的文本 soup.head.getText() ## u'Page title' ## or soup.head.text ## 获取body下的所有文本并以\\n分割 soup.body.getText('\\n') ## u'This is paragraph\\none\\n.\\nThis is paragraph\\ntwo\\n.' 实战 有了这些功能，文章开头给出的那个Demo就好做了，我们再来回顾下豆瓣的这个页面 http://movie.douban.com/tag/%E5%96%9C%E5%89%A7 如果要得到评分前100的所有电影，对这个页面需要提取两个信息：1、翻页链接；2、每部电影的信息（外链，图片，评分、简介、标题等） 当我们提取到所有电影的信息后再按评分进行排序，选出最高的即可，这里贴出翻页提取和电影信息提取的代码 ## filename: Grab.py from BeautifulSoup import BeautifulSoup , Tag import urllib2 import re from Log import LOG def LOG ( * argv ): sys . stderr . write ( * argv ) sys . stderr . write ( ' \\n ' ) class Grab (): url = '' soup = None def GetPage ( self , url ): if url . find ( 'http://' , 0 , 7 ) != 0 : url = 'http://' + url self . url = url LOG ( 'input url is: %s ' % self . url ) req = urllib2 . Request ( url , headers = { 'User-Agent' : \"Magic Browser\" }) try : page = urllib2 . urlopen ( req ) except : return return page . read () def ExtractInfo ( self , buf ): if not self . soup : try : self . soup = BeautifulSoup ( buf ) except : LOG ( 'soup failed in ExtractInfo : %s ' % self . url ) return try : items = self . soup . findAll ( attrs = { 'class' : 'item' }) except : LOG ( 'failed on find items: %s ' % self . url ) return links = [] objs = [] titles = [] scores = [] comments = [] intros = [] for item in items : try : pic = item . find ( attrs = { 'class' : 'nbg' }) link = pic [ 'href' ] obj = pic . img [ 'src' ] info = item . find ( attrs = { 'class' : 'pl2' }) title = re . sub ( '[ \\t ]+' , ' ' , info . a . getText () . replace ( '&amp;nbsp' , '' ) . replace ( ' \\n ' , '' )) star = info . find ( attrs = { 'class' : 'star clearfix' }) score = star . find ( attrs = { 'class' : 'rating_nums' }) . getText () . replace ( '&amp;nbsp' , '' ) comment = star . find ( attrs = { 'class' : 'pl' }) . getText () . replace ( '&amp;nbsp' , '' ) intro = info . find ( attrs = { 'class' : 'pl' }) . getText () . replace ( '&amp;nbsp' , '' ) except Exception , e : LOG ( 'process error in ExtractInfo: %s ' % self . url ) continue links . append ( link ) objs . append ( obj ) titles . append ( title ) scores . append ( score ) comments . append ( comment ) intros . append ( intro ) return ( links , objs , titles , scores , comments , intros ) def ExtractPageTurning ( self , buf ): links = set ([]) if not self . soup : try : self . soup = BeautifulSoup ( buf ) except : LOG ( 'soup failed in ExtractPageTurning: %s ' % self . url ) return try : pageturning = self . soup . find ( attrs = { 'class' : 'paginator' }) a_nodes = pageturning . findAll ( 'a' ) for a_node in a_nodes : href = a_node [ 'href' ] if href . find ( 'http://' , 0 , 7 ) == - 1 : href = self . url . split ( '?' )[ 0 ] + href links . add ( href ) except : LOG ( 'get pageturning failed in ExtractPageTurning: %s ' % self . url ) return links def Destroy ( self ): del self . soup self . soup = None 接着我们再来写个测试样例 ## filename: test.py #encoding: utf-8 from Grab import Grab import sys reload ( sys ) sys . setdefaultencoding ( 'utf-8' ) grab = Grab () buf = grab . GetPage ( 'http://movie.douban.com/tag/喜剧?start=160&amp;type=T' ) if not buf : print 'GetPage failed!' sys . exit () links , objs , titles , scores , comments , intros = grab . ExtractInfo ( buf ) for link , obj , title , score , comment , intro in zip ( links , objs , titles , scores , comments , intros ): print link + ' \\t ' + obj + ' \\t ' + title + ' \\t ' + score + ' \\t ' + comment + ' \\t ' + intro pageturning = grab . ExtractPageTurning ( buf ) for link in pageturning : print link grab . Destroy () OK，完成这一步接下来的事儿就自个看着办吧 本文只是介绍了BeautifulSoup的皮毛而已，目的是为了让大家快速学会一些基本要领，想当初我要用什么功能都是去BeautifulSoup的源代码里一个函数一个函数看然后才会的，一把辛酸泪啊，所以希望后来者能够通过更便捷的方式去掌握一些基本功能，也不枉我一字一句敲出这篇文章，尤其是这些代码的排版，真是伤透了脑筋 The end.","tags":"Language","title":"python网页解析利器——BeautifulSoup"},{"url":"http://localhost:8000/vpn简介以及国内外分流设置.html","text":"为了维护共产主义的纯洁性，为了阻挡资本主义万恶势力的入侵，我大中华局域网平地拔起，多少互联网用户搜索是用百度，看新闻是用新浪、QQ，社交是用人人微博之流，但总有一份不安分子想要使用Google、Facebook等一些不纯净的网站，以窥探资本主义的罪恶，为了满足这些用户的好奇心，VPN服务营运而生 vpn简介 === 在没有使用VPN的时候，我们访问网站的数据线路大致是这样的，我们以百度举例 你在浏览器输入www.baidu.com，DNS服务器给你解析出对应的ip 你的路由器将你的请求转给下一个路由器，下一个路由器再转给下下个路由器，一直到百度的服务器 百度服务器接收到请求，将百度的网页打包传给你，并带上你的ip 再经过一层层路由器的转发，百度返回的数据包回到你电脑上，由浏览器展示成网页的形式 如果你想知道你访问百度经过了哪些路由跳转，可以通过如下命令查看到 Linux： traceroute www.baidu.com windows（Dos界面下）: tracert www.baidu.com 同样，你访问国外的网站比如Google的时候也是通过以上的线路，只不过在你的请求数据到达Google服务器之前，要经过国内的统一出口，这个出口检测到你要访问Google，它可能会给你拦截下来，至于为什么，开篇已经说了，大家都懂的。这种拦截可能是根据ip拦截（比如facebook），也可能是根据你访问的数据内容拦截（比如Google），要知道HTTP请求是没有加密的，如果别人截获了你的HTTP请求，是可以知道你访问的具体内容的 但是并不是所有访问国外的请求都会被拦截，比如访问 who.is 就没事，于是VPN就有了用武之地。VPN主机可以理解为国外没有被拦截的服务器，当你连上VPN再访问国外网站比如google时，它的数据线路大致是这样的 你的请求通过国内出口到达VPN主机，这时你的数据是经过加密的，所以无法通过内容来过滤你的请求 VPN主机从数据里解密，知道你要访问Google，VPN主机再向Google发起请求，这时由于VPN主机和Google服务器都在国外，不会被拦截 Google服务器将数据返回给VPN主机，VPN主机将数据加密，再返回给你的电脑 所以我们有了VPN，就可以去一窥万恶的资本主义网络世界到底是个什么样子了。要连VPN，得知道VPN主机地址，有免费的也有收费的，为了用的心安理得我一直都是用收费的，我是在 vpnso.com 这个网站买的服务，支持Mac、windows、Android、IOS等设备，经济又实惠 VPN分流 === 但是有了VPN问题又来了，上面说到我们的所有请求都会通过VPN主机，也就是说我们如果连上VPN之后再访问百度，也要绕那么一大圈，这样既耗流量又浪费时间。但是聪明的程序员也想到了解决的办法，那就是设置路由表来分流 执行 大致的原理就是通过一些命令设置电脑的路由表，每次访问时系统会先去路由表查一下，如果在路由表里则不通过VPN访问，不在才走VPN，这样就可以实现访问国内国外网站的分流了。github上有一个项目专干这事儿，地址在 https://github.com/jimmyxu/chnroutes 。下面我简要列出主要操作 首先下载chnroute.py Mac下执行 python chnroutes.py -p mac ，生成ip-up和ip-down两个文件，将文件cp到/etc/ppp目录下，如果目录不存在则新建一个 windows下执行 python chnroutes.py -p win ，生成vpnup.bat和vpndown.bat，由于很多windows电脑没有装Python，可以直接去下载vpnup.bat和vpndown.bat两个文件，然后执行vpnup.bat。vpndown.bat其实没什么用，它是用来清除路由表的，但是电脑关机后自动清除 完成上面操作后再连上VPN，就可以实现分流了 测试 通过访问网站 分别访问 www.123cha.com 和 who.is ，如果显示你的ip不同，那么就成功了。前者显示的是你国内的ip，后者显示的是你VPN主机的ip 通过命令行 通过前面介绍的traceroute和tracert命令，我们以windows下的tracert命令举例 在DOS下执行 tracert www.baidu.com ，第一跳ip地址应该是192.168.xx.xx 执行 tracert www.google.com ，第一跳地址应该是10.10.xx.xx 可能遇到的问题 这里列举一个我遇到的问题 在公司内部大家都在一个局域网里，有时候为了方便共享会在自己机器上搭建Apache服务，然后把地址给别人访问，比如我的局域网ip是192.168.32.91，别人的是192.168.7.35，别好奇为什么最后两个域值不一样，那是因为我们不是连在同一个路由器上，这时候如果我连上了VPN，就无法访问到对方的主机，甚至ping都会失败。为什么呢，很简单，因为请求都是走VPN的，而VPN主机是无法访问公司内部局域网的ip的，所以就会失败 解决办法 在前面提到的路由表里添加一行记录，我们以windows平台为例，打开vpnup.bat文件，建议不要用记事本，可以装一个editplus，编辑文本文件很方便。在最后按照他的格式添加一行记录，路由地址配192.168.0.0，子网掩码配255.255.0.0。断开VPN，重新执行vpnup.bat（注意这时候可能会显示路由表已添加，因为你前面已经执行过一次vpnup.bat，不要管它，一直让它执行到最后一条），再连上VPN，看看是不是可以访问了","tags":"Skill","title":"vpn简介以及国内外分流设置"},{"url":"http://localhost:8000/wordpress自定义页面显示所有文章列表.html","text":"wordpress博客里有两种类型的网页，一种叫文章，一种叫页面（page），文章就是你发表的每篇博客所在的网页，页面就是你网站导航栏里的那些链接，比如\"首页\"，\"关于我\"这样的网页，这种网页的特点是集中展示某一类信息，比如首页展示每篇博客的摘要，\"关于我\"展示博主简介等等，自定义文章列表毫无疑问也是属于这一类的 page类型的网页都是根据模板生成的，wordpress默认没有这一类模板，因此需要自己写一个PHP脚本，首先我们找到模板所在的目录，假设你的wordpress所在目录为/var/www，那么模板脚本在/var/www/wp-content/themes/your_theme，其中your_theme是你所使用的主体包，在里面建立一个文件page-allpost.php，内容如下 <?php get_header (); ?> <style type= \"text/css\" > #table-allpost{border-collapse:collapse;} #table-allpost td,#table-allpost th{border:1px solid #98bf21;padding:3px 7px 2px 7px;text-align:center;} #table-allpost th{font-size:1.1em;text-align:center;padding-top:5px;padding-bottom:4px;background-color:#A7C942;color:#ffffff;} #table-allpost td{border:1px dotted #98bf21;} #table-allpost .td-left{text-align:left;} </style> <head><meta http-equiv= \"Content-Type\" content= \"text/html; charset=utf-8\" /></head> <div style= \"padding-bottom:10px\" ><strong> 全部文章 </strong></div> <div id= \"page-allpost\" > <table id= \"table-allpost\" > <tr> <th><strong> 编号 </strong></th> <th><strong> 发布时间 </strong></th> <th><strong> 标题 </strong></th> </tr> <?php $Count_Posts = wp_count_posts (); $Num_Posts = $Count_Posts -> publish ; query_posts ( 'posts_per_page=-1&caller_get_posts=1' ); while ( have_posts () ) : the_post (); $Num = sprintf ( \"%03d\" , $Num_Posts ); echo '<tr>' ; echo '<th>' . $Num . '</th>' ; echo '<td>' ; the_time ( get_option ( 'date_format' )); echo '</td><td class=\"td-left\";><a href=\"' ; the_permalink (); echo '\" title=\"' . esc_attr ( get_the_title () ) . '\">' ; the_title (); echo '</a></td></tr>' ; $Num_Posts -- ; endwhile ; wp_reset_query (); ?> </table> </div> <?php get_sidebar (); ?> <?php get_footer (); ?> 保存好之后，再去wordpress后台新建一个页面，注意不是发表文章，而是在仪表盘的\"页面\"一栏里选择新建页面，标题写\"全部文章\"，内容为空，别名（固定链接）设置为\" allpost \"，注意这里的别名必须和之前的脚本名page-allpost.php对应。点击保存，然后刷新你的站点首页，看看导航栏里是不是有了\"全部文章\"选项，点击进去看看是不是如下效果","tags":"Skill","title":"wordpress自定义页面显示所有文章列表"},{"url":"http://localhost:8000/如何打造舒适的linux开发环境.html","text":"首先要说明的是今天讲的不是安装教程，而是讲使用方式。写这篇文章的初衷是考虑到很多在校大学生对Linux接触较少，即便接触也只是装装系统，没有实际用过Linux开发环境，而互联网公司普遍都是Linux开发环境，可以说整个互联网就是建立在Linux服务器之上，因此越早使用Linux，工作之后就能越快上手。但如果你的方向是windows客户端开发，那后面的内容都没必要看了。 请允许我先吐槽一下windows集成开发环境（IDE），在我读书的时候大家用的最多的是VC6.0，现在发展到了VS2012，并不是说IDE不好，相反它会极大的提高开发效率，但那是对老程序员来讲是这样，对于一个新手来说，我们在乎的不是写代码有多快，而是了解程序从开发到运行各个步骤是如何串联起来。在IDE中，你不用写makefile，不用关心程序的编译过程以及代码之间的相互关联，你要做的只是建立工程，写好代码，点击一下run，背后的一切IDE都帮你做好了，等你毕业后进入BAT这些互联网企业，发现一切都和学校里不一样，你是那么的不适应，这时候你想，要是在学校就能接触这样的开发环境那该多好。 互联网公司的工作环境一般是windows电脑+Linux远程主机的模式，windows电脑用来上网发邮件满足办公需求，Linux服务器用来写代码满足开发需求，所谓是各司其职配合周到。对于个人用户来说，我们虽没有远程Linux主机，但可以安装Linux虚拟机，不管是在windows下还是Mac下都可以通过虚拟机软件VMware来安装Linux系统，推荐选择Ubuntu或Centos，这两个版本网上对应教程较多，更重要的是它们都自带包管理工具（apt-get和yum），可以方便的安装软件。装好虚拟机后，如果你直接在虚拟机上操作，会让人觉得很别扭，比如你在windows下上网查到的东西没法复制到虚拟机里，完全用虚拟机里Linux自带的浏览器软件又觉得操作没那么方便，这时候你又开始怀念window，还好，在windows下我们有终端模拟器。 在百度这样的大公司有成千上万台Linux服务器，这些服务器位于几十甚至几千公里外的机房，而程序员们就坐在西二旗百度大厦的办公室，你有没有想过他们是如何工作的呢。其实我们只需要通过ssh协议登陆远程主机就可以，但windows上没有直接的ssh命令可用，因此我们需要先安装终端模拟器软件xshell或SecureCRT，其中xshell有免费版，因此我推荐xshell。正如互联网公司的windows+远程Linux服务器模式，我们可以将自己的Linux虚拟机当做远程服务器，在自己的windows系统下安装终端模拟器，通过ssh协议登陆Linux主机，登陆上之后你就可以在xshell的窗口下操作Linux主机，而xshell是命令行窗口，抛弃了Linux一切不相干的图形图像界面，可以让你沉浸在纯正的Linux环境中，全身心的投入开发，至于查资料聊QQ发邮件等办公需求，就交给windows去完成。如果你是Mac用户，那更简单，找到Terminal程序，打开之后直接通过ssh连接Linux主机即可，不过Mac自带的Terminal不太好用，可以使用iTerm来替代。 最后大致说一下ssh的使用方式，首先确保你的Linux主机开启了ssh服务（一般默认是开启的），远程登陆命令为 ssh username@hostname ，其中username是你的Linux用户名，hostname是主机名，或者是ip地址，回车输入密码即可登录。windows下的终端模拟器有很多图形化的设置选项，只要你配置好可以通过点击按钮自动连接主机，但你要知道它背后隐藏的其实就是这样一条简单的命令。题图就是我在Mac上通过iTerm使用ssh命令登陆我的博客主机的登陆界面，红框标记的是登陆命令，通过这种方式，我就可以登陆远在美国的Ubuntu主机，在上面去做任何我想做的事。 前面只是介绍了开发环境和使用原理，具体的安装细节可以百度Google，当你配置好了Linux开发环境，就可以徜徉在编程的乐趣中。Linux就像一盒巧克力，总有你喜欢的口味，只是需要你慢慢去发现","tags":"Skill","title":"如何打造舒适的linux开发环境"},{"url":"http://localhost:8000/店大莫欺人.html","text":"锤子约架zealer事件高潮已经过去了好几天，不管是自媒体还是传统媒体也都发表了各种轮调，最后我们发现其实约架的两人都没赢，真正赢的是媒体，因为这两人给他们制造了足够多的话题讨论点，以至于我这个普通用户也想借此机会发表一下自己的一些看法，而选择这个时候写文章，一来是我不喜欢凑热闹，二来是我觉得高潮之后的宁静会带给人更冷静的思考。 锤子发布的时候我没有看直播，只是后来听说可以当一场不错的相声来看，于是才一口气看完了两个多小时的发布会。其实我以前没听过罗永浩这个人，第一次在网上看到他还是韩寒方舟子吵架那一次，老罗好像亲自跑到方舟子上班的地方找他理论，并找人拍成视频发到网上，那时我第一反应是觉得竟然有这么好事的哥们，因为那时我以为他只是一个普通的路人，直到最近才联想到那个就是大名鼎鼎的老罗。 看完锤子发布后我是支持他的，互联网老是被那几个巨头垄断，每天新闻都是BAT收购哪儿哪儿公司，看着也让人觉得腻，这时出来一个搅局者就好比一部沉闷的电影在邋遢的叙事中突然插入一个精彩的段子，让人一下子抖擞了精神。老罗是一个很会传销的人，他甚至将情怀这个词绑架在手机上并大肆宣传，这让那些自认为拥有情怀的少数分子一下觉得终于找到了党组织，不跟着吆喝几句都不好意思标榜自己曾经不可一世的情怀。对于一个从强者林立的手机圈异军突起的\"小公司\"，这样的宣传无疑是起到了很大的作用，一时吸引了无数互联网用户的关注，风光无两。但渐渐地听多了情怀二字，我反而觉得有点怪异，就好比古时候给贞节女立的牌坊一样，锤子现在给我的感觉是贞节还没见到，牌坊却先立了。但是不管是贞节还是情怀，被大肆宣传后反而会因过度曝光而失去本有的色彩，有些东西本来就该静静的躺在那里，让别人去发现和欣赏。 对于王自如，我想如果不是因为这次的约架事件，恐怕他的名声还只停留在数码爱好者的小众圈子里。可能大家不知道的是在锤子开完发布会后，王自如也在北京开了个zealer2.0的发布会，据说观众有1800多人，但和锤子发布会的5000大众相比还是小巫见大巫。zealer的发布会我后来也看了，其实测评工具的发布会是相对无趣的，他也不能像老罗一样在台上将所有手机挨个儿黑个遍以满足广大网民吐槽的心理，如果不是一直以来都看zealer视频，我想没有人会愿意去看他们的发布会。这次约架之后，我发现身边平时不怎么关注锤子和zealer的人都在谈论这件事，它就好像互联网圈子里的一个流行指标，你不谈它就会out，广大网民知道锤子的人不在少数，但知道zealer并看过他们视频的估计不及前者十分之一，所以在谈论这件事时大多数人只能说说zealer不该拿手机厂商的投资，zealer好像在黑锤子等等不用多思考就能品头论足的事情，而这几个点恰好也是老罗对zealer展开猛烈攻击的突破点，可见老罗布道功力的深厚。但是在这几点尤其是拿手机厂商投资这件事上，zealer确实是有口难辩，所谓拿人手短，在利益和投资厂商的双重制约下，还标榜客观独立第三方，连小白用户都不信，更何况是老罗呢。 在谈论这个事情时先要抛开所有\"粉丝\"因素，不管是老罗的情怀粉还是zealer的视频粉，在忠实支持者的眼里他们各自都是无可侵犯的，因为对他们的侵犯代表着对支持者的侵犯，就好比当年的超女，社会大众越是批评他们，那些支持者反而越是疯狂，zealer和超女在某方面是有共性的，他们都来自草根，他们都和支持者一起成长，而不像老罗在创办锤子时已是名满天下，即便老罗在发布会一再强调\"作为一个小公司\"，但是在zealer面前他是十足的\"大公司\"，倒不是因为它真的大，而是zealer实在太小了。社会往往同情弱者，所以在王自如被老罗批斗的体无完肤之后，支持zealer的路人多数是因为对王自如的同情和对老罗的憎恨，在台上一个咄咄逼人不懂礼节甚至对人进行人身攻击，一个低调谦卑处处退让面对人身攻击也只能忍气吞声，在这一点上公众自有判断。而支持老罗的无非就是说zealer拿人钱财肯定会替人消灾，还标榜公平客观不厚道。在辩论中我们看到王自如有口难辩，在拿手机厂商投资上理亏词穷，而老罗则是在猛烈的批斗下也不惜通过承认苹果三星是这个行业最厉害的厂商而狠狠扇了自己\"东半球最好用的手机\"称号几巴掌。最后老罗带着胜利之姿耀武扬威的继续修造它情怀的牌坊，嘴角带着一丝微笑，而王自如则更加坚定信念去迎接艰难而未知的旅程，脸上又多了几颗痘痘。 不管怎样，zealer的视频我会继续看，因为他是免费并且带有娱乐和科普性的，老罗的锤子我不会去买，因为他的情怀已经变质。抛开辩论时老罗撒下的烟雾弹，只针对于zealer测评锤子这件事上，我挺zealer。最后，我默默的在小米官网拍下了米4的订单。","tags":"View","title":"店大莫欺人"},{"url":"http://localhost:8000/强符号和弱符号.html","text":"之前在 extern \"C\" 用法详解 中已经提到过符号的概念，它是编译器对变量和函数的一种标记，编译器对C和C++代码在生产符号时规则也是不一样的，符号除了本身名字的区别外，还有强符号和弱符号之分 我们先看一段简单的代码 /* test.c */ void hello () ; int main () { hello () ; return 0 ; } 很显然，这段代码是没法链接通过的，它会报错 undefined reference to hello ，说的是hello未定义，因为这里我们只声明了函数hello，而没有定义它。但是我们把代码稍作修改如下 __attribute__((weak)) void hello(); int main() { hello(); return 0; } 这时你会发现，编译链接都可通过，但是运行会报错，因为这时我们将hello声明为了弱符号，在链接时弱符号会被链接器当做0，执行一个地址为0的函数当然会报错，改为如下代码就不会报错了，只是它没有任何输出 __attribute__((weak)) void hello(); int main() { if(hello) hello(); return 0; } 编译器认为， 函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号 ，链接器在处理强符号和弱符号时有如下规则 不同目标文件中，不允许有同名的强符号 如果一个符号在某个目标文件中是强符号，在其它目标文件中为弱符号，选择强符号 如果一个符号在所有目标文件中都是弱符号，选择占用空间最大的，比如目标文件A中有double global_var，文件B中有int global_var，double占用8字节，大于int的4字节，A和B链接后，符号global占8字节 对此我们可以简单的验证一下，有如下两个文件 /* 1.c */ char global_var ; int main () { return 0 ; } /* 2.c */ int global_var ; 全局变量global_var在两个文件中都没有初始化，因此都是弱符号，执行编译命令 gcc 1.c 2.c ，用readelf查看符号表 readelf -s a.out ，为了查看方便我们只输出最后几行 Num : Value Size Type Bind Vis Ndx Name 62 : 0000000000600818 4 OBJECT GLOBAL DEFAULT 25 global_var 63 : 0000000000400474 11 FUNC GLOBAL DEFAULT 13 main 64 : 0000000000400358 0 FUNC GLOBAL DEFAULT 11 _init 这里符号global_var占用的size是4，说明链接器选择的是占用空间更大的int global_var，我们再稍作修改，将1.c中的全局变量初始化，如下 /* 1.c */ char global_var = 1 ; int main () { return 0 ; } /* 2.c */ int global_var ; 这时1.c中的global_var为强符号，2.c中的global_var为弱符号，同样编译之后用readelf查看符号表 readelf -s a.out 如下 Num : Value Size Type Bind Vis Ndx Name 62 : 0000000000600818 1 OBJECT GLOBAL DEFAULT 25 global_var 63 : 0000000000400474 11 FUNC GLOBAL DEFAULT 13 main 64 : 0000000000400358 0 FUNC GLOBAL DEFAULT 11 _init 此时符号global_var占用的size是1，说明链接器选择的是强符号 在写代码时应该尽量避免有不同类型的符号，否则会引发非常诡异且不易察觉的错误，为了避免可以采取如下措施： 上策：消除所有的全局变量 中策：将全局变量声明为static类型，并提供接口供访问 下策：全局变量一定要初始化，哪怕初始化为0 必备：打开gcc的-fno-common选项，它会禁止有不同类型的符号 说了这么多，好像在说应该尽量用强符号，那弱符号有什么用呢，所谓存在即合理，有时候我们甚至需要显示定义弱符号，这对库函数会非常有用，比如库中的弱符号可以被用户自定义的强符号覆盖，从而实现自定义的库版本，或者在使用某些扩展功能时，用户可以定义一个弱符号，当链接了该功能时，功能模块可以正常使用，如果去掉功能模块，程序也可正常链接，只是缺少某些功能而已，比如我们可以通过下面的代码判断程序是否链接了pthread库，从而决定执行什么样的操作 /* test.c */ #include <stdio.h> #include <pthread.h> __attribute__ (( weak )) int pthread_create ( pthread_t * , const pthread_attr_t * , void * ( * )( void * ), void * ); int main () { if ( pthread_create ) { printf ( \"This is multi-thread version! \\n \" ); } else { printf ( \"This is single-thread version! \\n \" ); } return 0 ; } 编译运行结果如下 $ gcc test.c $ ./a.out This is single-thread version! $ gcc test.c -lpthread $ a.out This is multi-thread version! EOF 本文参考： 《程序员的自我修养》3.5.5章节 http://blog.csdn.net/astrotycoon/article/details/8008629","tags":"Language","title":"强符号和弱符号"},{"url":"http://localhost:8000/没有main函数的helloworld.html","text":"几乎所有程序员的第一堂课都是学习helloworld程序，下面我们先来重温一下经典的C语言helloworld /* hello.c */ #include <stdio.h> int main () { printf ( \"hello world! \\n \" ); return 0 ; } 这是一个简单得不能再单的程序，但它包含有一个程序最重要的部分，那就是我们在几乎所有代码中都能看到的main函数，我们编译成可执行文件并查看符号表，过滤出里面的函数如下（为了方便查看我手动调整了grep的输出的格式，所以和你的输出格式是不一样的） $ gcc hello.c -o hello $ readelf -s hello | grep FUNC Num: Value Size Type Bind Vis Ndx Name 27: 000000000040040c 0 FUNC LOCAL DEFAULT 13 call_gmon_start 32: 0000000000400430 0 FUNC LOCAL DEFAULT 13 __do_global_dtors_aux 35: 00000000004004a0 0 FUNC LOCAL DEFAULT 13 frame_dummy 40: 0000000000400580 0 FUNC LOCAL DEFAULT 13 __do_global_ctors_aux 47: 00000000004004e0 2 FUNC GLOBAL DEFAULT 13 __libc_csu_fini 48: 00000000004003e0 0 FUNC GLOBAL DEFAULT 13 _start 51: 0000000000000000 0 FUNC GLOBAL DEFAULT UND puts@@GLIBC_2.2.5 52: 00000000004005b8 0 FUNC GLOBAL DEFAULT 14 _fini 53: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@@GLIBC_ 58: 00000000004004f0 137 FUNC GLOBAL DEFAULT 13 __libc_csu_init 62: 00000000004004c4 21 FUNC GLOBAL DEFAULT 13 main 63: 0000000000400390 0 FUNC GLOBAL DEFAULT 11 _init 大家都知道用户的代码是从main函数开始执行的，虽然我们只写了一个main函数，但从上面的函数表可以看到还有其它很多函数，比如_start函数。实际上程序真正的入口并不是main函数，我们以下面命令对hello.c代码进行编译 $ gcc hello.c -nostdlib /usr/bin/ld: warning: cannot find entry symbol _start ; defaulting to 0000000000400144 -nostdlib命令是指不链接标准库，报错说找不到entry symbol _start，这里是说找不到入口符号_start，也就是说程序的真正入口是_start函数 实际上main函数只是用户代码的入口，它会由系统库去调用，在main函数之前，系统库会做一些初始化工作，比如分配全局变量的内存，初始化堆、线程等，当main函数执行完后，会通过exit()函数做一些清理工作，用户可以自己实现_start函数 /* hello_start.c */ #include <stdio.h> #include <stdlib.h> _start ( void ) { printf ( \"hello world! \\n \" ); exit ( 0 ); } 执行如下编译命令并运行 $ gcc hello_start.c -nostartfiles -o hello_start $ ./hello_start hello world! 这里的-nostartfiles的功能是Do not use the standard system startup files when linking，也就是不使用标准的startup files，但是还是会链接系统库，所以程序还是可以执行的。同样我们查看符号表 $ readelf -s hello_start | grep FUNC Num: Value Size Type Bind Vis Ndx Name 20: 0000000000400350 24 FUNC GLOBAL DEFAULT 10 _start 21: 0000000000000000 0 FUNC GLOBAL DEFAULT UND puts@@GLIBC_2.2.5 22: 0000000000000000 0 FUNC GLOBAL DEFAULT UND exit@@GLIBC_2.2.5 现在就只剩下三个函数了，并且都是我们自己实现的，其中printf由于只有一个参数会被编译器优化为puts函数，在编译时加-fno-builtin选项可以关掉优化 如果我们在_start函数中去掉exit(0)语句，程序执行会出core，这是因为_start函数执行完程序就结束了，而我们自己实现的_start里面没有调用exit()去清理内存 好不容易去掉了main函数，这时又发现必须得有一个_start函数，是不是让人很烦，其实_start函数只是一个默认入口，我们是可以指定入口的 /* hello_nomain.c */ #include <stdio.h> #include <stdlib.h> int nomain () { printf ( \"hello world! \\n \" ); exit ( 0 ); } 采用如下命令编译 $ gcc hello_nomain.c -nostartfiles -e nomain -o hello_nomain 其中-e选项可以指定程序入口符号，查看符号表如下 $ readelf -s hello_nomain | grep FUNC Num: Value Size Type Bind Vis Ndx Name 20: 0000000000000000 0 FUNC GLOBAL DEFAULT UND puts@@GLIBC_2.2.5 21: 0000000000000000 0 FUNC GLOBAL DEFAULT UND exit@@GLIBC_2.2.5 22: 0000000000400350 24 FUNC GLOBAL DEFAULT 10 nomain 对比hello_start的符号表发现只是将_start换成了nomain 到这里我们就很清楚了，程序默认的入口是标准库里的_start函数，它会做一些初始化工作，调用用户的main函数，最后再做一些清理工作，我们可以自己写_start函数来覆盖标准库里的_start，甚至可以自己指定程序的入口","tags":"Language","title":"没有main函数的helloworld"},{"url":"http://localhost:8000/独自下场.html","text":"前天还在厦门游玩的时候，看新闻知道李娜微博发布了退役信，尽管前几天就有消息放出说要退役，但当事情真的发生时，还是会给人不少的触动，那天新闻头条都是关于这件事。 今天是亚运会比赛第二天，李娜在北京正式举办了退役发布会，这不得不说是一种巧合，一个体制外的运动员退役，一场体制内的赛事开始。新闻头条开始被亚运会占据，中国金牌榜暂时落后韩国，人们关注着这场似乎所有人都在关注的赛事，它只是一种茶余饭后的谈资，并不是因为个人兴趣而去关注，而今天我要站在一个网球爱好者的角度谈一件事。 两座大满贯奖杯，世界排名第二，这是李娜离开时所取得的成绩，可以说她是在职业生涯的顶峰选择了离开，就好像你走在一条铺满了金币的路上，只要你走下去，前面会有越来越多的金币属于你，而选择离开你将放弃那些金币。为什么我要以金币做比，因为网球赛事和奖金之间密不可分的关系。 网球是一项高度职业化和商业化的运动，而且主要是以个人项目为主，尽管也有双打，但双打的含金量和关注度无法和单打同日而语，这就是为什么郑洁06年就拿到澳网双打冠军，其影响力远不如李娜11年闯入澳网单打决赛。网球对于运动员来说是一项职业，它不同于足球和篮球这种群体运动，只要你加入了俱乐部，不管打得好坏，都是可以领到固定的工资的，而对于网球运动员来说，他们的工资就是参加比赛的奖金，取得的成绩越好，奖金也就越高，运动员想要生存，就需要不停的去参加比赛赚取奖金，因为参加这些比赛的机票酒店全部都需要自费，你不努力，没人可以帮你，所以当李娜赢得了比赛，她也只是为自己而赢。网球的商业化体现在它的巡回赛上，在世界最流行的几项球类运动中，网球是唯一一个女子比赛受关注度几乎和男子比赛齐平的运动，并且也是唯一你在世界各地都能看到高水平比赛的运动，比如去年中国网球公开赛的决赛，德约科维奇就和纳达尔上演了当今网坛最高水准的对决，刚刚开赛的武汉网球公开赛，也有小威和莎拉波娃这样的顶级女子选手。这不同于想看科比詹姆斯你只能去美国，想看梅西C罗你只能去欧洲。每年在世界各地会有很多巡回赛，运动员们会有选择的去不同的地方去参加比赛，所以并不是所有赛事都能见到所有最顶尖的选手，一般巡回赛只有32位选手参加，而只有一种赛事会强制排名前100的运动员都得参加，这种赛事就是大满贯。 在李娜拿了11年法网冠军时，国内很多人都跟着欢呼雀跃，以为大满贯就是拿下所有顶级赛事的冠军，好像只有这样的成绩才值得他们如此庆祝，对于这些人只能劝他们先去了解一下网球基本知识再说。网球大满贯一年有四次，按时间分别是澳大利亚网球公开赛、法国网球公开赛，温布尔顿网球公开赛和美国网球公开赛，四大满贯比赛都有接近百年的历史，在公开赛时代以前网球只是某些贵族的游戏，后来才慢慢开始向世界范围推广。让我来告诉你一个中国人夺得一次大满贯冠军有多难，先说男子，中国目前为止没有排名进100的男子选手，也就是说他们甚至没有直接参赛的资格，所以他们如果要参加大满贯，先要打资格赛，资格赛会产生28个参赛名额，加上排名前100的选手，一共128名选手参赛，要赢得冠军，必须连赢7场比赛，目前中国男子选手还从来没有赢得过一场大满贯比赛。可能有人说一年四次大满贯比赛，机会总会有，但事实是从2003年到目前为止，费德勒（17）纳达尔（14）德约科维奇（7），这三个人获得的大满贯冠军总数加起来是38个，你可以想象一下其它选手要从他们中间突围有多难。而女子比赛相对好一些，冠军并不总是集中在那几个人中间，但即便如此，近10年来，拿过女子大满贯冠军的球员只来自10个国家，这其中就包括中国，也是亚洲唯一的一个。所以当我们为李娜夺得法网冠军而兴奋时，不仅仅是因为她赢得了一项顶级赛事，更重要的是她打破了欧美选手对大满贯的垄断。 李娜向来也是以一个破坏者的姿态出现，她早年因不满全运会的安排而选择退役，后来又不满体制对自身的约束而选择单飞，她破坏的是顽固的制度，赢得的却是人生的巅峰。我以前总会有\"恨不早生\"的感叹，乔丹在NBA驰骋时我还在上小学，罗纳尔多赢得世界杯时我刚上初中，费德勒拿第一个大满贯时我初中未毕业，所幸的是在我拿起网球拍之后，我看着李娜一次次突破，仿佛是自己在一点一点进步一样。离世界第一只有一步之遥，但我们无法再过多要求，就到这里吧，这样就很好了。","tags":"View","title":"独自下场"},{"url":"http://localhost:8000/让你的程序更优雅的sleep.html","text":"sleep的作用无需多说，几乎每种语言都提供了类似的函数，调用起来也很简单。sleep的作用无非是让程序等待若干时间，而为了达到这样的目的，其实有很多种方式，最简单的往往也是最粗暴的，我们就以下面这段代码来举例说明（ 注：本文提及的程序编译运行环境为Linux ） /* filename: test.cpp */ #include <stdio.h> #include <unistd.h> #include <pthread.h> #include <signal.h> class TestServer { public : TestServer () : run_ ( true ) {}; ~ TestServer (){}; void Start () { pthread_create ( & thread_ , NULL , ThreadProc , ( void * ) this ); } void Stop () { run_ = false ; } void Wait () { pthread_join ( thread_ , NULL ); } void Proc () { int count = 0 ; while ( run_ ) { printf ( \"sleep count:%d \\n \" , ++ count ); sleep ( 5 ); } } private : bool run_ ; pthread_t thread_ ; static void * ThreadProc ( void * arg ) { TestServer * me = static_cast < TestServer *> ( arg ); me -> Proc (); return NULL ; } }; TestServer g_server ; void StopService () { g_server . Stop (); } void StartService () { g_server . Start (); g_server . Wait (); } void SignalHandler ( int sig ) { switch ( sig ) { case SIGINT : StopService (); default : break ; } } int main ( int argc , char * argv []) { signal ( SIGINT , SignalHandler ); StartService (); return 0 ; } 这段代码描述了一个简单的服务程序，为了简化我们省略了服务的处理逻辑，也就是Proc函数的内容，这里我们只是周期性的打印某条语句，为了达到周期性的目的，我们用sleep来实现，每隔5秒钟打印一次。在main函数中我们对SIGINT信号进行了捕捉，当程序在终端启动之后，如果你输入ctr+c，这会向程序发送中断信号，一般来说程序会退出，而这里我们捕捉到了这个信号，会按我们自己的逻辑来处理，也就是调用server的Stop函数。执行编译命令 g++ test.cpp -o test -lpthread 然后在终端输入 ./test 运行程序，这时程序每隔5秒会在屏幕上打印一条语句，按下ctl+c，你会发现程序并没有立即退出，而是等待了一会儿才退出，究其原因，当按下ctl+c发出中断信号时，程序捕捉到并执行自己的逻辑，也就是调用了server的Stop函数，运行标记位run_被置为false，Proc函数检测到run_为false则退出循环，程序结束，但有可能（应该说大多数情况都是如此）此时Proc正好执行到sleep那一步，而sleep是将程序挂起，由于我们捕捉到了中断信号，因此它不会退出，而是继续挂起直到时间满足为止。这个sleep显然显得不够优雅，下面介绍两种能快速退出的方式。 自定义sleep 在我们调用系统提供的sleep时我们是无法在函数内部做其它事情的，基于此我们就萌生出一种想法，如果在sleep中能够检测到退出变量，那岂不是就能快速退出了，没错，事情就是这样子的，通过自定义sleep，我们将时间片分割成更小的片段，每隔一个片段检测一次，这样就能将程序的退出延迟时间缩小为这个更小的片段，自定义的sleep如下 void sleep(int seconds, const bool* run) { int count = seconds * 10; while (*run && count > 0) { --count; usleep(100000); } } 需要注意的是，这个sleep的第二个参数必须是指针类型的，因为我们需要检测到它的实时值，而不只是使用它传入进来的值，相应的函数调用也得稍作修改，完整的代码如下 /* filename: test2.cpp */ #include <stdio.h> #include <unistd.h> #include <pthread.h> #include <signal.h> class TestServer { public : TestServer () : run_ ( true ) {}; ~ TestServer (){}; void Start () { pthread_create ( & thread_ , NULL , ThreadProc , ( void * ) this ); } void Stop () { run_ = false ; } void Wait () { pthread_join ( thread_ , NULL ); } void Proc () { int count = 0 ; while ( run_ ) { printf ( \"sleep count:%d \\n \" , ++ count ); sleep ( 5 , & run_ ); } } private : bool run_ ; pthread_t thread_ ; void sleep ( int seconds , const bool * run ) { int count = seconds * 10 ; while ( * run && count > 0 ) { -- count ; usleep ( 100000 ); } } static void * ThreadProc ( void * arg ) { TestServer * me = static_cast < TestServer *> ( arg ); me -> Proc (); return NULL ; } }; TestServer g_server ; void StopService () { g_server . Stop (); } void StartService () { g_server . Start (); g_server . Wait (); } void SignalHandler ( int sig ) { switch ( sig ) { case SIGINT : StopService (); default : break ; } } int main ( int argc , char * argv []) { signal ( SIGINT , SignalHandler ); StartService (); return 0 ; } 编译 g++ test2.cpp -o test ，运行 ./test ，当程序启动之后按 ctl+c ，看程序是不是很快就退出了。 其实这种退出并不是立马退出，而是将sleep的等待时间分成了更小的时间片，上例是0.1秒，也就是说在按下ctr+c之后，程序其实还会延时0到0.1秒才会退出，只不过这个时间很短，看上去就像立马退出一样。 用条件变量实现sleep 大致的思想就是，在循环时等待一个条件变量，并设置超时时间，如果在这个时间之内有其它线程触发了条件变量，等待会立即退出，否则会一直等到设置的时间，这样就可以通过对条件变量的控制来实现sleep，并且可以在需要的时候立马退出。 条件变量往往会和互斥锁搭配使用，互斥锁的逻辑很简单，如果一个线程获取了互斥锁，其它线程就无法获取，也就是说如果两个线程同时执行到了 pthread_mutex_lock 语句，只有一个线程会执行完成，而另一个线程会阻塞，直到有线程调用 pthread_mutex_unlock 才会继续往下执行。所以我们往往在多线程访问同一内存区域时会用到互斥锁，以防止多个线程同时修改某一块内存区域。本例用到的函数有如下几个，互斥锁相关函数有 int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr); int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); int pthread_mutex_destroy(pthread_mutex_t *mutex); 以上函数功能分别是初始化、加锁、解锁、销毁。条件变量相关函数有 int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_destroy(pthread_cond_t *cond); 以上函数功能分别是初始化、超时等待条件变量、触发条件变量、销毁。这里需要解释一下pthread_cond_timedwait和pthread_cond_signal函数 pthread_cond_timedwait 这个函数调用之后会阻塞，也就是类似sleep的作用，但是它会在两种情况下被唤醒：1、条件变量cond被触发时；2、系统时间到达abstime时，注意这里是绝对时间，不是相对时间。它比sleep的高明之处就在第一点。另外它还有一个参数是mutex，当执行这个函数时，它的效果等同于在函数入口处先对mutex加锁，在出口处再对mutex解锁，当有多线程调用这个函数时，可以按这种方式去理解 pthread_cond_signal 它只有一个参数cond，作用很简单，就是触发等待cond的线程，注意，它一次只会触发一个，如果要触发所有等待cond的县城，需要用到pthread_cond_broadcast函数，参数和用法都是一样的 有了以上背景知识，就可以更加优雅的实现sleep，主要关注Proc函数和Stop函数，完整的代码如下 /* filename: test3.cpp */ #include <stdio.h> #include <unistd.h> #include <pthread.h> #include <signal.h> #include <sys/time.h> class TestServer { public : TestServer () : run_ ( true ) { pthread_mutex_init ( & mutex_ , NULL ); pthread_cond_init ( & cond_ , NULL ); }; ~ TestServer () { pthread_mutex_destroy ( & mutex_ ); pthread_cond_destroy ( & cond_ ); }; void Start () { pthread_create ( & thread_ , NULL , ThreadProc , ( void * ) this ); } void Stop () { run_ = false ; pthread_mutex_lock ( & mutex_ ); pthread_cond_signal ( & cond_ ); pthread_mutex_unlock ( & mutex_ ); } void Wait () { pthread_join ( thread_ , NULL ); } void Proc () { pthread_mutex_lock ( & mutex_ ); struct timeval now ; int count = 0 ; while ( run_ ) { printf ( \"sleep count:%d \\n \" , ++ count ); gettimeofday ( & now , NULL ); struct timespec outtime ; outtime . tv_sec = now . tv_sec + 5 ; outtime . tv_nsec = now . tv_usec * 1000 ; pthread_cond_timedwait ( & cond_ , & mutex_ , & outtime ); } pthread_mutex_unlock ( & mutex_ ); } private : bool run_ ; pthread_t thread_ ; pthread_mutex_t mutex_ ; pthread_cond_t cond_ ; static void * ThreadProc ( void * arg ) { TestServer * me = static_cast < TestServer *> ( arg ); me -> Proc (); return NULL ; } }; TestServer g_server ; void StopService () { g_server . Stop (); } void StartService () { g_server . Start (); g_server . Wait (); } void SignalHandler ( int sig ) { switch ( sig ) { case SIGINT : StopService (); default : break ; } } int main ( int argc , char * argv []) { signal ( SIGINT , SignalHandler ); StartService (); return 0 ; } 和test2.cpp一样，编译之后运行，程序每隔5秒在屏幕打印一行输出，输入ctr+c，程序会立马退出","tags":"Language","title":"让你的程序更优雅的sleep"}]}